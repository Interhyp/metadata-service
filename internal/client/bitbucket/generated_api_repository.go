/*
Bitbucket Data Center

This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).

API version: 8.19
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bitbucketclient

import (
    "context"
    "fmt"
    aurestclientapi "github.com/StephanHCB/go-autumn-restclient/api"
    "net/http"
    urlUtil "net/url"
    "strings"
)

type RepositoryAPI interface {

    /*
       AddLabel Add repository label
    */
    AddLabel(ctx context.Context, projectKey string, repositorySlug string, restLabel RestLabel) (RestLabel, aurestclientapi.ParsedResponse, error)

    // AddLabelExecutes the request
    // @return RestLabel
    AddLabelRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIAddLabelRequest

    /*
       CreateBranch Create branch
    */
    CreateBranch(ctx context.Context, projectKey string, repositorySlug string, restBranchCreateRequest RestBranchCreateRequest) (RestBranch, aurestclientapi.ParsedResponse, error)

    // CreateBranchExecutes the request
    // @return RestBranch
    CreateBranchRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPICreateBranchRequest

    /*
       CreateBranchForRepository Create branch
    */
    CreateBranchForRepository(ctx context.Context, projectKey string, repositorySlug string, restCreateBranchRequest RestCreateBranchRequest) (RestBranch, aurestclientapi.ParsedResponse, error)

    // CreateBranchForRepositoryExecutes the request
    // @return RestBranch
    CreateBranchForRepositoryRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPICreateBranchForRepositoryRequest

    /*
       CreateComment Add a new commit comment
    */
    CreateComment(ctx context.Context, projectKey string, commitId string, repositorySlug string, restComment RestComment, since string) (RestComment, aurestclientapi.ParsedResponse, error)

    // CreateCommentExecutes the request
    // @return RestComment
    CreateCommentRequest(ctx context.Context, projectKey string, commitId string, repositorySlug string) RepositoryAPICreateCommentRequest

    /*
       CreateRestrictions1 Create multiple ref restrictions
    */
    CreateRestrictions1(ctx context.Context, projectKey string, repositorySlug string, restRestrictionRequest []RestRestrictionRequest) (RestRefRestriction, aurestclientapi.ParsedResponse, error)

    // CreateRestrictions1Executes the request
    // @return RestRefRestriction
    CreateRestrictions1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPICreateRestrictions1Request

    /*
       CreateTag Create tag
    */
    CreateTag(ctx context.Context, projectKey string, repositorySlug string, restGitTagCreateRequest RestGitTagCreateRequest) (RestTag, aurestclientapi.ParsedResponse, error)

    // CreateTagExecutes the request
    // @return RestTag
    CreateTagRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPICreateTagRequest

    /*
       CreateTagForRepository Create tag
    */
    CreateTagForRepository(ctx context.Context, projectKey string, repositorySlug string, restCreateTagRequest RestCreateTagRequest) (RestTag, aurestclientapi.ParsedResponse, error)

    // CreateTagForRepositoryExecutes the request
    // @return RestTag
    CreateTagForRepositoryRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPICreateTagForRepositoryRequest

    /*
       CreateWebhook1 Create webhook
    */
    CreateWebhook1(ctx context.Context, projectKey string, repositorySlug string, restWebhook RestWebhook) (RestWebhook, aurestclientapi.ParsedResponse, error)

    // CreateWebhook1Executes the request
    // @return RestWebhook
    CreateWebhook1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPICreateWebhook1Request

    /*
       Delete5 Delete pull request auto-merge settings
    */
    Delete5(ctx context.Context, projectKey string, repositorySlug string) (aurestclientapi.ParsedResponse, error)

    // Delete5Executes the request
    Delete5Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIDelete5Request

    /*
       DeleteAttachment Delete an attachment
    */
    DeleteAttachment(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) (aurestclientapi.ParsedResponse, error)

    // DeleteAttachmentExecutes the request
    DeleteAttachmentRequest(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) RepositoryAPIDeleteAttachmentRequest

    /*
       DeleteAttachmentMetadata Delete attachment metadata
    */
    DeleteAttachmentMetadata(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) (aurestclientapi.ParsedResponse, error)

    // DeleteAttachmentMetadataExecutes the request
    DeleteAttachmentMetadataRequest(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) RepositoryAPIDeleteAttachmentMetadataRequest

    /*
       DeleteAutoDeclineSettings1 Delete auto decline settings
    */
    DeleteAutoDeclineSettings1(ctx context.Context, projectKey string, repositorySlug string) (aurestclientapi.ParsedResponse, error)

    // DeleteAutoDeclineSettings1Executes the request
    DeleteAutoDeclineSettings1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIDeleteAutoDeclineSettings1Request

    /*
       DeleteBranch Delete branch
    */
    DeleteBranch(ctx context.Context, projectKey string, repositorySlug string, restBranchDeleteRequest RestBranchDeleteRequest) (aurestclientapi.ParsedResponse, error)

    // DeleteBranchExecutes the request
    DeleteBranchRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIDeleteBranchRequest

    /*
       DeleteComment Delete a commit comment
    */
    DeleteComment(ctx context.Context, projectKey string, commentId string, commitId string, repositorySlug string, version string) (aurestclientapi.ParsedResponse, error)

    // DeleteCommentExecutes the request
    DeleteCommentRequest(ctx context.Context, projectKey string, commentId string, commitId string, repositorySlug string) RepositoryAPIDeleteCommentRequest

    /*
       DeleteRepositoryHook Delete repository hook
    */
    DeleteRepositoryHook(ctx context.Context, projectKey string, hookKey string, repositorySlug string) (aurestclientapi.ParsedResponse, error)

    // DeleteRepositoryHookExecutes the request
    DeleteRepositoryHookRequest(ctx context.Context, projectKey string, hookKey string, repositorySlug string) RepositoryAPIDeleteRepositoryHookRequest

    /*
       DeleteRestriction1 Delete a ref restriction
    */
    DeleteRestriction1(ctx context.Context, projectKey string, id string, repositorySlug string) (aurestclientapi.ParsedResponse, error)

    // DeleteRestriction1Executes the request
    DeleteRestriction1Request(ctx context.Context, projectKey string, id string, repositorySlug string) RepositoryAPIDeleteRestriction1Request

    /*
       DeleteTag Delete tag
    */
    DeleteTag(ctx context.Context, projectKey string, name string, repositorySlug string) (aurestclientapi.ParsedResponse, error)

    // DeleteTagExecutes the request
    DeleteTagRequest(ctx context.Context, projectKey string, name string, repositorySlug string) RepositoryAPIDeleteTagRequest

    /*
       DeleteWebhook1 Delete webhook
    */
    DeleteWebhook1(ctx context.Context, projectKey string, webhookId string, repositorySlug string) (aurestclientapi.ParsedResponse, error)

    // DeleteWebhook1Executes the request
    DeleteWebhook1Request(ctx context.Context, projectKey string, webhookId string, repositorySlug string) RepositoryAPIDeleteWebhook1Request

    /*
       DisableHook1 Disable repository hook
    */
    DisableHook1(ctx context.Context, projectKey string, hookKey string, repositorySlug string) (RestRepositoryHook, aurestclientapi.ParsedResponse, error)

    // DisableHook1Executes the request
    // @return RestRepositoryHook
    DisableHook1Request(ctx context.Context, projectKey string, hookKey string, repositorySlug string) RepositoryAPIDisableHook1Request

    /*
       EditFile Edit file
    */
    EditFile(ctx context.Context, path string, projectKey string, repositorySlug string, exampleMultipartFormData ExampleMultipartFormData) (RestCommit, aurestclientapi.ParsedResponse, error)

    // EditFileExecutes the request
    // @return RestCommit
    EditFileRequest(ctx context.Context, path string, projectKey string, repositorySlug string) RepositoryAPIEditFileRequest

    /*
       EnableHook1 Enable repository hook
    */
    EnableHook1(ctx context.Context, projectKey string, hookKey string, repositorySlug string) (RestRepositoryHook, aurestclientapi.ParsedResponse, error)

    // EnableHook1Executes the request
    // @return RestRepositoryHook
    EnableHook1Request(ctx context.Context, projectKey string, hookKey string, repositorySlug string) RepositoryAPIEnableHook1Request

    /*
       FindBranches Get branches with ref change activities for repository
    */
    FindBranches(ctx context.Context, projectKey string, repositorySlug string, filterText string, start float32, limit float32) (FindByCommit200Response, aurestclientapi.ParsedResponse, error)

    // FindBranchesExecutes the request
    // @return FindByCommit200Response
    FindBranchesRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIFindBranchesRequest

    /*
       FindByCommit Get branch
    */
    FindByCommit(ctx context.Context, projectKey string, commitId string, repositorySlug string, start float32, limit float32) (FindByCommit200Response, aurestclientapi.ParsedResponse, error)

    // FindByCommitExecutes the request
    // @return FindByCommit200Response
    FindByCommitRequest(ctx context.Context, projectKey string, commitId string, repositorySlug string) RepositoryAPIFindByCommitRequest

    /*
       FindWebhooks1 Find webhooks
    */
    FindWebhooks1(ctx context.Context, projectKey string, repositorySlug string, event string, statistics bool) (aurestclientapi.ParsedResponse, error)

    // FindWebhooks1Executes the request
    FindWebhooks1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIFindWebhooks1Request

    /*
       Get5 Get pull request auto-merge settings
    */
    Get5(ctx context.Context, projectKey string, repositorySlug string) (RestAutoMergeRestrictedSettings, aurestclientapi.ParsedResponse, error)

    // Get5Executes the request
    // @return RestAutoMergeRestrictedSettings
    Get5Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGet5Request

    /*
       GetAllLabelsForRepository Get repository labels
    */
    GetAllLabelsForRepository(ctx context.Context, projectKey string, repositorySlug string) (RestLabel, aurestclientapi.ParsedResponse, error)

    // GetAllLabelsForRepositoryExecutes the request
    // @return RestLabel
    GetAllLabelsForRepositoryRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetAllLabelsForRepositoryRequest

    /*
       GetArchive Stream archive of repository
    */
    GetArchive(ctx context.Context, projectKey string, repositorySlug string, path string, filename string, at string, prefix string, format string) (aurestclientapi.ParsedResponse, error)

    // GetArchiveExecutes the request
    GetArchiveRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetArchiveRequest

    /*
       GetAttachment Get an attachment
    */
    GetAttachment(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) (aurestclientapi.ParsedResponse, error)

    // GetAttachmentExecutes the request
    GetAttachmentRequest(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) RepositoryAPIGetAttachmentRequest

    /*
       GetAttachmentMetadata Get attachment metadata
    */
    GetAttachmentMetadata(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) (RestAttachmentMetadata, aurestclientapi.ParsedResponse, error)

    // GetAttachmentMetadataExecutes the request
    // @return RestAttachmentMetadata
    GetAttachmentMetadataRequest(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) RepositoryAPIGetAttachmentMetadataRequest

    /*
       GetAutoDeclineSettings1 Get auto decline settings
    */
    GetAutoDeclineSettings1(ctx context.Context, projectKey string, repositorySlug string) (RestAutoDeclineSettings, aurestclientapi.ParsedResponse, error)

    // GetAutoDeclineSettings1Executes the request
    // @return RestAutoDeclineSettings
    GetAutoDeclineSettings1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetAutoDeclineSettings1Request

    /*
       GetBranches Find branches
    */
    GetBranches(ctx context.Context, projectKey string, repositorySlug string, boostMatches bool, orderBy string, details bool, filterText string, base string, start float32, limit float32) (GetBranches200Response, aurestclientapi.ParsedResponse, error)

    // GetBranchesExecutes the request
    // @return GetBranches200Response
    GetBranchesRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetBranchesRequest

    /*
       GetChanges Get changes in commit
    */
    GetChanges(ctx context.Context, projectKey string, commitId string, repositorySlug string, withComments string, since string, start float32, limit float32) (GetChanges1200Response, aurestclientapi.ParsedResponse, error)

    // GetChangesExecutes the request
    // @return GetChanges1200Response
    GetChangesRequest(ctx context.Context, projectKey string, commitId string, repositorySlug string) RepositoryAPIGetChangesRequest

    /*
       GetChanges1 Get changes made in commit
    */
    GetChanges1(ctx context.Context, projectKey string, repositorySlug string, until string, since string, start float32, limit float32) (GetChanges1200Response, aurestclientapi.ParsedResponse, error)

    // GetChanges1Executes the request
    // @return GetChanges1200Response
    GetChanges1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetChanges1Request

    /*
       GetComment Get a commit comment
    */
    GetComment(ctx context.Context, projectKey string, commentId string, commitId string, repositorySlug string) (RestComment, aurestclientapi.ParsedResponse, error)

    // GetCommentExecutes the request
    // @return RestComment
    GetCommentRequest(ctx context.Context, projectKey string, commentId string, commitId string, repositorySlug string) RepositoryAPIGetCommentRequest

    /*
       GetComments Search for commit comments
    */
    GetComments(ctx context.Context, projectKey string, commitId string, repositorySlug string, path string, since string, start float32, limit float32) (GetComments200Response, aurestclientapi.ParsedResponse, error)

    // GetCommentsExecutes the request
    // @return GetComments200Response
    GetCommentsRequest(ctx context.Context, projectKey string, commitId string, repositorySlug string) RepositoryAPIGetCommentsRequest

    /*
       GetCommit Get commit by ID
    */
    GetCommit(ctx context.Context, projectKey string, commitId string, repositorySlug string, path string) (RestCommit, aurestclientapi.ParsedResponse, error)

    // GetCommitExecutes the request
    // @return RestCommit
    GetCommitRequest(ctx context.Context, projectKey string, commitId string, repositorySlug string) RepositoryAPIGetCommitRequest

    /*
       GetCommits Get commits
    */
    GetCommits(ctx context.Context, projectKey string, repositorySlug string, avatarScheme string, path string, withCounts string, followRenames string, until string, avatarSize string, since string, merges string, ignoreMissing string, start float32, limit float32) (GetCommits200Response, aurestclientapi.ParsedResponse, error)

    // GetCommitsExecutes the request
    // @return GetCommits200Response
    GetCommitsRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetCommitsRequest

    /*
       GetConfigurations1 Get hook scripts
    */
    GetConfigurations1(ctx context.Context, projectKey string, repositorySlug string, start float32, limit float32) (GetConfigurations200Response, aurestclientapi.ParsedResponse, error)

    // GetConfigurations1Executes the request
    // @return GetConfigurations200Response
    GetConfigurations1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetConfigurations1Request

    /*
       GetContent Get file content at revision
    */
    GetContent(ctx context.Context, projectKey string, repositorySlug string, noContent string, at string, size string, blame string, type_ string) (aurestclientapi.ParsedResponse, error)

    // GetContentExecutes the request
    GetContentRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetContentRequest

    /*
       GetContent1 Get file content
    */
    GetContent1(ctx context.Context, path string, projectKey string, repositorySlug string, noContent string, at string, size string, blame string, type_ string) (GetContent1200Response, aurestclientapi.ParsedResponse, error)

    // GetContent1Executes the request
    // @return GetContent1200Response
    GetContent1Request(ctx context.Context, path string, projectKey string, repositorySlug string) RepositoryAPIGetContent1Request

    /*
       GetDefaultBranch1 Get default branch
       Deprecated
    */
    GetDefaultBranch1(ctx context.Context, projectKey string, repositorySlug string) (RestBranch, aurestclientapi.ParsedResponse, error)

    // GetDefaultBranch1Executes the request
    // @return RestBranch
    // Deprecated
    GetDefaultBranch1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetDefaultBranch1Request

    /*
       GetLatestInvocation1 Get last webhook invocation details
    */
    GetLatestInvocation1(ctx context.Context, projectKey string, webhookId string, repositorySlug string, event string, outcome string) (RestDetailedInvocation, aurestclientapi.ParsedResponse, error)

    // GetLatestInvocation1Executes the request
    // @return RestDetailedInvocation
    GetLatestInvocation1Request(ctx context.Context, projectKey string, webhookId string, repositorySlug string) RepositoryAPIGetLatestInvocation1Request

    /*
       GetMergeBase Get the common ancestor between two commits
    */
    GetMergeBase(ctx context.Context, projectKey string, commitId string, repositorySlug string, otherCommitId string) (RestCommit, aurestclientapi.ParsedResponse, error)

    // GetMergeBaseExecutes the request
    // @return RestCommit
    GetMergeBaseRequest(ctx context.Context, projectKey string, commitId string, repositorySlug string) RepositoryAPIGetMergeBaseRequest

    /*
       GetPullRequestSettings1 Get pull request settings
    */
    GetPullRequestSettings1(ctx context.Context, projectKey string, repositorySlug string) (RestRepositoryPullRequestSettings, aurestclientapi.ParsedResponse, error)

    // GetPullRequestSettings1Executes the request
    // @return RestRepositoryPullRequestSettings
    GetPullRequestSettings1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetPullRequestSettings1Request

    /*
       GetRefChangeActivity Get ref change activity
    */
    GetRefChangeActivity(ctx context.Context, projectKey string, repositorySlug string, ref string, start float32, limit float32) (GetRefChangeActivity200Response, aurestclientapi.ParsedResponse, error)

    // GetRefChangeActivityExecutes the request
    // @return GetRefChangeActivity200Response
    GetRefChangeActivityRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetRefChangeActivityRequest

    /*
       GetRepositories1 Search for repositories
    */
    GetRepositories1(ctx context.Context, archived string, projectname string, projectkey string, visibility string, name string, permission string, state string, start float32, limit float32) (GetRepositoriesRecentlyAccessed200Response, aurestclientapi.ParsedResponse, error)

    // GetRepositories1Executes the request
    // @return GetRepositoriesRecentlyAccessed200Response
    GetRepositories1Request(ctx context.Context) RepositoryAPIGetRepositories1Request

    /*
       GetRepositoriesRecentlyAccessed Get recently accessed repositories
    */
    GetRepositoriesRecentlyAccessed(ctx context.Context, permission string, start float32, limit float32) (GetRepositoriesRecentlyAccessed200Response, aurestclientapi.ParsedResponse, error)

    // GetRepositoriesRecentlyAccessedExecutes the request
    // @return GetRepositoriesRecentlyAccessed200Response
    GetRepositoriesRecentlyAccessedRequest(ctx context.Context) RepositoryAPIGetRepositoriesRecentlyAccessedRequest

    /*
       GetRepositoryHook1 Get repository hook
    */
    GetRepositoryHook1(ctx context.Context, projectKey string, hookKey string, repositorySlug string) (RestRepositoryHook, aurestclientapi.ParsedResponse, error)

    // GetRepositoryHook1Executes the request
    // @return RestRepositoryHook
    GetRepositoryHook1Request(ctx context.Context, projectKey string, hookKey string, repositorySlug string) RepositoryAPIGetRepositoryHook1Request

    /*
       GetRepositoryHooks1 Get repository hooks
    */
    GetRepositoryHooks1(ctx context.Context, projectKey string, repositorySlug string, type_ string, start float32, limit float32) (GetRepositoryHooks1200Response, aurestclientapi.ParsedResponse, error)

    // GetRepositoryHooks1Executes the request
    // @return GetRepositoryHooks1200Response
    GetRepositoryHooks1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetRepositoryHooks1Request

    /*
       GetRestriction1 Get a ref restriction
    */
    GetRestriction1(ctx context.Context, projectKey string, id string, repositorySlug string) (RestRefRestriction, aurestclientapi.ParsedResponse, error)

    // GetRestriction1Executes the request
    // @return RestRefRestriction
    GetRestriction1Request(ctx context.Context, projectKey string, id string, repositorySlug string) RepositoryAPIGetRestriction1Request

    /*
       GetRestrictions1 Search for ref restrictions
    */
    GetRestrictions1(ctx context.Context, projectKey string, repositorySlug string, matcherType string, matcherId string, type_ string, start float32, limit float32) (GetRestrictions1200Response, aurestclientapi.ParsedResponse, error)

    // GetRestrictions1Executes the request
    // @return GetRestrictions1200Response
    GetRestrictions1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetRestrictions1Request

    /*
       GetSettings1 Get repository hook settings
    */
    GetSettings1(ctx context.Context, projectKey string, hookKey string, repositorySlug string) (ExampleSettings, aurestclientapi.ParsedResponse, error)

    // GetSettings1Executes the request
    // @return ExampleSettings
    GetSettings1Request(ctx context.Context, projectKey string, hookKey string, repositorySlug string) RepositoryAPIGetSettings1Request

    /*
       GetStatistics1 Get webhook statistics
    */
    GetStatistics1(ctx context.Context, projectKey string, webhookId string, repositorySlug string, event string) (interface{}, aurestclientapi.ParsedResponse, error)

    // GetStatistics1Executes the request
    // @return interface{}
    GetStatistics1Request(ctx context.Context, projectKey string, webhookId string, repositorySlug string) RepositoryAPIGetStatistics1Request

    /*
       GetStatisticsSummary1 Get webhook statistics summary
    */
    GetStatisticsSummary1(ctx context.Context, projectKey string, webhookId string, repositorySlug string) (interface{}, aurestclientapi.ParsedResponse, error)

    // GetStatisticsSummary1Executes the request
    // @return interface{}
    GetStatisticsSummary1Request(ctx context.Context, projectKey string, webhookId string, repositorySlug string) RepositoryAPIGetStatisticsSummary1Request

    /*
       GetStatus Get synchronization status
    */
    GetStatus(ctx context.Context, projectKey string, repositorySlug string, at string) (RestRefSyncStatus, aurestclientapi.ParsedResponse, error)

    // GetStatusExecutes the request
    // @return RestRefSyncStatus
    GetStatusRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetStatusRequest

    /*
       GetTag Get tag
    */
    GetTag(ctx context.Context, projectKey string, name string, repositorySlug string) (RestTag, aurestclientapi.ParsedResponse, error)

    // GetTagExecutes the request
    // @return RestTag
    GetTagRequest(ctx context.Context, projectKey string, name string, repositorySlug string) RepositoryAPIGetTagRequest

    /*
       GetTags Find tag
    */
    GetTags(ctx context.Context, projectKey string, repositorySlug string, orderBy string, filterText string, start float32, limit float32) (GetTags200Response, aurestclientapi.ParsedResponse, error)

    // GetTagsExecutes the request
    // @return GetTags200Response
    GetTagsRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetTagsRequest

    /*
       GetWebhook1 Get webhook
    */
    GetWebhook1(ctx context.Context, projectKey string, webhookId string, repositorySlug string, statistics string) (RestWebhook, aurestclientapi.ParsedResponse, error)

    // GetWebhook1Executes the request
    // @return RestWebhook
    GetWebhook1Request(ctx context.Context, projectKey string, webhookId string, repositorySlug string) RepositoryAPIGetWebhook1Request

    /*
       React React to a comment
    */
    React(ctx context.Context, projectKey string, commentId string, commitId string, emoticon string, repositorySlug string) (RestUserReaction, aurestclientapi.ParsedResponse, error)

    // ReactExecutes the request
    // @return RestUserReaction
    ReactRequest(ctx context.Context, projectKey string, commentId string, commitId string, emoticon string, repositorySlug string) RepositoryAPIReactRequest

    /*
       RemoveConfiguration1 Remove a hook script
    */
    RemoveConfiguration1(ctx context.Context, projectKey string, scriptId string, repositorySlug string) (aurestclientapi.ParsedResponse, error)

    // RemoveConfiguration1Executes the request
    RemoveConfiguration1Request(ctx context.Context, projectKey string, scriptId string, repositorySlug string) RepositoryAPIRemoveConfiguration1Request

    /*
       RemoveLabel Remove repository label
    */
    RemoveLabel(ctx context.Context, projectKey string, labelName string, repositorySlug string) (aurestclientapi.ParsedResponse, error)

    // RemoveLabelExecutes the request
    RemoveLabelRequest(ctx context.Context, projectKey string, labelName string, repositorySlug string) RepositoryAPIRemoveLabelRequest

    /*
       SaveAttachmentMetadata Save attachment metadata
    */
    SaveAttachmentMetadata(ctx context.Context, projectKey string, attachmentId string, repositorySlug string, body string) (aurestclientapi.ParsedResponse, error)

    // SaveAttachmentMetadataExecutes the request
    SaveAttachmentMetadataRequest(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) RepositoryAPISaveAttachmentMetadataRequest

    /*
       SearchWebhooks Search webhooks
    */
    SearchWebhooks(ctx context.Context, projectKey string, repositorySlug string, scopeType string, event string, statistics bool) (aurestclientapi.ParsedResponse, error)

    // SearchWebhooksExecutes the request
    SearchWebhooksRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPISearchWebhooksRequest

    /*
       Set1 Create or update the pull request auto-merge settings
    */
    Set1(ctx context.Context, projectKey string, repositorySlug string, restAutoMergeSettingsRequest RestAutoMergeSettingsRequest) (RestAutoMergeRestrictedSettings, aurestclientapi.ParsedResponse, error)

    // Set1Executes the request
    // @return RestAutoMergeRestrictedSettings
    Set1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPISet1Request

    /*
       SetAutoDeclineSettings1 Create auto decline settings
    */
    SetAutoDeclineSettings1(ctx context.Context, projectKey string, repositorySlug string, restAutoDeclineSettingsRequest RestAutoDeclineSettingsRequest) (RestAutoDeclineSettings, aurestclientapi.ParsedResponse, error)

    // SetAutoDeclineSettings1Executes the request
    // @return RestAutoDeclineSettings
    SetAutoDeclineSettings1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPISetAutoDeclineSettings1Request

    /*
       SetConfiguration1 Create/update a hook script
    */
    SetConfiguration1(ctx context.Context, projectKey string, scriptId string, repositorySlug string, restHookScriptTriggers RestHookScriptTriggers) (RestHookScriptConfig, aurestclientapi.ParsedResponse, error)

    // SetConfiguration1Executes the request
    // @return RestHookScriptConfig
    SetConfiguration1Request(ctx context.Context, projectKey string, scriptId string, repositorySlug string) RepositoryAPISetConfiguration1Request

    /*
       SetDefaultBranch1 Update default branch
       Deprecated
    */
    SetDefaultBranch1(ctx context.Context, projectKey string, repositorySlug string, restBranch RestBranch) (aurestclientapi.ParsedResponse, error)

    // SetDefaultBranch1Executes the request
    // Deprecated
    SetDefaultBranch1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPISetDefaultBranch1Request

    /*
       SetEnabled Disable synchronization
    */
    SetEnabled(ctx context.Context, projectKey string, repositorySlug string, restRefSyncStatus RestRefSyncStatus) (RestRefSyncStatus, aurestclientapi.ParsedResponse, error)

    // SetEnabledExecutes the request
    // @return RestRefSyncStatus
    SetEnabledRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPISetEnabledRequest

    /*
       SetSettings1 Update repository hook settings
    */
    SetSettings1(ctx context.Context, projectKey string, hookKey string, repositorySlug string, exampleSettings ExampleSettings) (ExampleSettings, aurestclientapi.ParsedResponse, error)

    // SetSettings1Executes the request
    // @return ExampleSettings
    SetSettings1Request(ctx context.Context, projectKey string, hookKey string, repositorySlug string) RepositoryAPISetSettings1Request

    /*
       Stream Stream files
    */
    Stream(ctx context.Context, projectKey string, repositorySlug string, at string) (ExampleFiles, aurestclientapi.ParsedResponse, error)

    // StreamExecutes the request
    // @return ExampleFiles
    StreamRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIStreamRequest

    /*
       Stream1 Stream files with last modified commit in path
    */
    Stream1(ctx context.Context, path string, projectKey string, repositorySlug string, at string) (ExampleFiles, aurestclientapi.ParsedResponse, error)

    // Stream1Executes the request
    // @return ExampleFiles
    Stream1Request(ctx context.Context, path string, projectKey string, repositorySlug string) RepositoryAPIStream1Request

    /*
       StreamChanges Compare commits
    */
    StreamChanges(ctx context.Context, projectKey string, repositorySlug string, fromRepo string, from string, to string, start float32, limit float32) (GetChanges1200Response, aurestclientapi.ParsedResponse, error)

    // StreamChangesExecutes the request
    // @return GetChanges1200Response
    StreamChangesRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIStreamChangesRequest

    /*
       StreamCommits Get accessible commits
    */
    StreamCommits(ctx context.Context, projectKey string, repositorySlug string, fromRepo string, from string, to string, start float32, limit float32) (GetCommits200Response, aurestclientapi.ParsedResponse, error)

    // StreamCommitsExecutes the request
    // @return GetCommits200Response
    StreamCommitsRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIStreamCommitsRequest

    /*
       StreamDiff Get diff between revisions
    */
    StreamDiff(ctx context.Context, commitId string, repositorySlug string, path string, projectKey string, srcPath string, avatarSize string, filter string, avatarScheme string, contextLines string, autoSrcPath string, whitespace string, withComments string, since string) (RestDiff, aurestclientapi.ParsedResponse, error)

    // StreamDiffExecutes the request
    // @return RestDiff
    StreamDiffRequest(ctx context.Context, commitId string, repositorySlug string, path string, projectKey string) RepositoryAPIStreamDiffRequest

    /*
       StreamDiff1 Get diff between commits
    */
    StreamDiff1(ctx context.Context, path string, projectKey string, repositorySlug string, contextLines string, fromRepo string, srcPath string, from string, to string, whitespace string, start float32, limit float32) (StreamDiff1200Response, aurestclientapi.ParsedResponse, error)

    // StreamDiff1Executes the request
    // @return StreamDiff1200Response
    StreamDiff1Request(ctx context.Context, path string, projectKey string, repositorySlug string) RepositoryAPIStreamDiff1Request

    /*
       StreamFiles Get files in directory
    */
    StreamFiles(ctx context.Context, projectKey string, repositorySlug string, at string, start float32, limit float32) (StreamFiles200Response, aurestclientapi.ParsedResponse, error)

    // StreamFilesExecutes the request
    // @return StreamFiles200Response
    StreamFilesRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIStreamFilesRequest

    /*
       StreamFiles1 Get files in directory
    */
    StreamFiles1(ctx context.Context, path string, projectKey string, repositorySlug string, at string, start float32, limit float32) (StreamFiles200Response, aurestclientapi.ParsedResponse, error)

    // StreamFiles1Executes the request
    // @return StreamFiles200Response
    StreamFiles1Request(ctx context.Context, path string, projectKey string, repositorySlug string) RepositoryAPIStreamFiles1Request

    /*
       StreamPatch Get patch content at revision
    */
    StreamPatch(ctx context.Context, projectKey string, repositorySlug string, until string, allAncestors string, since string) (aurestclientapi.ParsedResponse, error)

    // StreamPatchExecutes the request
    StreamPatchRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIStreamPatchRequest

    /*
       StreamRaw Get raw content of a file at revision
    */
    StreamRaw(ctx context.Context, path string, projectKey string, repositorySlug string, at string, markup string, htmlEscape string, includeHeadingId string, hardwrap string) (aurestclientapi.ParsedResponse, error)

    // StreamRawExecutes the request
    StreamRawRequest(ctx context.Context, path string, projectKey string, repositorySlug string) RepositoryAPIStreamRawRequest

    /*
       StreamRawDiff Get raw diff for path
    */
    StreamRawDiff(ctx context.Context, projectKey string, repositorySlug string, contextLines string, srcPath string, until string, whitespace string, since string) (aurestclientapi.ParsedResponse, error)

    // StreamRawDiffExecutes the request
    StreamRawDiffRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIStreamRawDiffRequest

    /*
       StreamRawDiff1 Get raw diff for path
    */
    StreamRawDiff1(ctx context.Context, path string, projectKey string, repositorySlug string, contextLines string, srcPath string, until string, whitespace string, since string) (aurestclientapi.ParsedResponse, error)

    // StreamRawDiff1Executes the request
    StreamRawDiff1Request(ctx context.Context, path string, projectKey string, repositorySlug string) RepositoryAPIStreamRawDiff1Request

    /*
       Synchronize Manual synchronization
    */
    Synchronize(ctx context.Context, projectKey string, repositorySlug string, restRefSyncRequest RestRefSyncRequest) (RestRejectedRef, aurestclientapi.ParsedResponse, error)

    // SynchronizeExecutes the request
    // @return RestRejectedRef
    SynchronizeRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPISynchronizeRequest

    /*
       TestWebhook1 Test webhook
    */
    TestWebhook1(ctx context.Context, projectKey string, repositorySlug string, restWebhookCredentials RestWebhookCredentials, webhookId int32, sslVerificationRequired string, url string) (interface{}, aurestclientapi.ParsedResponse, error)

    // TestWebhook1Executes the request
    // @return interface{}
    TestWebhook1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPITestWebhook1Request

    /*
       UnReact Remove a reaction from comment
    */
    UnReact(ctx context.Context, projectKey string, commentId string, commitId string, emoticon string, repositorySlug string) (aurestclientapi.ParsedResponse, error)

    // UnReactExecutes the request
    UnReactRequest(ctx context.Context, projectKey string, commentId string, commitId string, emoticon string, repositorySlug string) RepositoryAPIUnReactRequest

    /*
       Unwatch Stop watching commit
    */
    Unwatch(ctx context.Context, projectKey string, commitId string, repositorySlug string) (aurestclientapi.ParsedResponse, error)

    // UnwatchExecutes the request
    UnwatchRequest(ctx context.Context, projectKey string, commitId string, repositorySlug string) RepositoryAPIUnwatchRequest

    /*
       Unwatch2 Stop watching repository
    */
    Unwatch2(ctx context.Context, projectKey string, repositorySlug string) (aurestclientapi.ParsedResponse, error)

    // Unwatch2Executes the request
    Unwatch2Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIUnwatch2Request

    /*
       UpdateComment Update a commit comment
    */
    UpdateComment(ctx context.Context, projectKey string, commentId string, commitId string, repositorySlug string, restComment RestComment) (RestComment, aurestclientapi.ParsedResponse, error)

    // UpdateCommentExecutes the request
    // @return RestComment
    UpdateCommentRequest(ctx context.Context, projectKey string, commentId string, commitId string, repositorySlug string) RepositoryAPIUpdateCommentRequest

    /*
       UpdatePullRequestSettings1 Update pull request settings
    */
    UpdatePullRequestSettings1(ctx context.Context, projectKey string, repositorySlug string, restRepositoryPullRequestSettings RestRepositoryPullRequestSettings) (RestRepositoryPullRequestSettings, aurestclientapi.ParsedResponse, error)

    // UpdatePullRequestSettings1Executes the request
    // @return RestRepositoryPullRequestSettings
    UpdatePullRequestSettings1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIUpdatePullRequestSettings1Request

    /*
       UpdateWebhook1 Update webhook
    */
    UpdateWebhook1(ctx context.Context, projectKey string, webhookId string, repositorySlug string, restWebhook RestWebhook) (RestWebhook, aurestclientapi.ParsedResponse, error)

    // UpdateWebhook1Executes the request
    // @return RestWebhook
    UpdateWebhook1Request(ctx context.Context, projectKey string, webhookId string, repositorySlug string) RepositoryAPIUpdateWebhook1Request

    /*
       Watch Watch commit
    */
    Watch(ctx context.Context, projectKey string, commitId string, repositorySlug string) (aurestclientapi.ParsedResponse, error)

    // WatchExecutes the request
    WatchRequest(ctx context.Context, projectKey string, commitId string, repositorySlug string) RepositoryAPIWatchRequest

    /*
       Watch2 Watch repository
    */
    Watch2(ctx context.Context, projectKey string, repositorySlug string, restRepository RestRepository) (aurestclientapi.ParsedResponse, error)

    // Watch2Executes the request
    Watch2Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIWatch2Request
}

 type RepositoryAPIAddLabelRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    restLabel *RestLabel
}

    // The label to apply
func (r *RepositoryAPIAddLabelRequest) RestLabel(restLabel RestLabel) *RepositoryAPIAddLabelRequest {
    r.restLabel = &restLabel
    return r
}

func (r *RepositoryAPIAddLabelRequest) Execute() (RestLabel, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.AddLabelExecute(r)
}

func (a *RepositoryAPIRepository) AddLabelRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIAddLabelRequest {
    return RepositoryAPIAddLabelRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) AddLabelExecute(r *RepositoryAPIAddLabelRequest) (RestLabel, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/labels"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeAddLabelCall(r.ctx, requestURL, r.restLabel)
}

func (a *RepositoryAPIRepository) AddLabel(ctx context.Context, projectKey string, repositorySlug string, restLabel RestLabel) (RestLabel, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/labels"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeAddLabelCall(ctx, requestURL, restLabel)
}

func (a *RepositoryAPIRepository) makeAddLabelCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestLabel, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPost
	requestUrl := requestURL.String()

    var result RestLabel
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestLabel](&response)
        if err == nil {
            result = response.Body.(RestLabel)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPICreateBranchRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    restBranchCreateRequest *RestBranchCreateRequest
}

func (r *RepositoryAPICreateBranchRequest) RestBranchCreateRequest(restBranchCreateRequest RestBranchCreateRequest) *RepositoryAPICreateBranchRequest {
    r.restBranchCreateRequest = &restBranchCreateRequest
    return r
}

func (r *RepositoryAPICreateBranchRequest) Execute() (RestBranch, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.CreateBranchExecute(r)
}

func (a *RepositoryAPIRepository) CreateBranchRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPICreateBranchRequest {
    return RepositoryAPICreateBranchRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) CreateBranchExecute(r *RepositoryAPICreateBranchRequest) (RestBranch, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/branch-utils/latest/projects/{projectKey}/repos/{repositorySlug}/branches"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeCreateBranchCall(r.ctx, requestURL, r.restBranchCreateRequest)
}

func (a *RepositoryAPIRepository) CreateBranch(ctx context.Context, projectKey string, repositorySlug string, restBranchCreateRequest RestBranchCreateRequest) (RestBranch, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/branch-utils/latest/projects/{projectKey}/repos/{repositorySlug}/branches"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeCreateBranchCall(ctx, requestURL, restBranchCreateRequest)
}

func (a *RepositoryAPIRepository) makeCreateBranchCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestBranch, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPost
	requestUrl := requestURL.String()

    var result RestBranch
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 409 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestBranch](&response)
        if err == nil {
            result = response.Body.(RestBranch)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPICreateBranchForRepositoryRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    restCreateBranchRequest *RestCreateBranchRequest
}

    // The request to create a branch containing a &lt;strong&gt;name&lt;/strong&gt;, &lt;strong&gt;startPoint&lt;/strong&gt;, and optionally a &lt;strong&gt;message&lt;/strong&gt;
func (r *RepositoryAPICreateBranchForRepositoryRequest) RestCreateBranchRequest(restCreateBranchRequest RestCreateBranchRequest) *RepositoryAPICreateBranchForRepositoryRequest {
    r.restCreateBranchRequest = &restCreateBranchRequest
    return r
}

func (r *RepositoryAPICreateBranchForRepositoryRequest) Execute() (RestBranch, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.CreateBranchForRepositoryExecute(r)
}

func (a *RepositoryAPIRepository) CreateBranchForRepositoryRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPICreateBranchForRepositoryRequest {
    return RepositoryAPICreateBranchForRepositoryRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) CreateBranchForRepositoryExecute(r *RepositoryAPICreateBranchForRepositoryRequest) (RestBranch, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/branches"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeCreateBranchForRepositoryCall(r.ctx, requestURL, r.restCreateBranchRequest)
}

func (a *RepositoryAPIRepository) CreateBranchForRepository(ctx context.Context, projectKey string, repositorySlug string, restCreateBranchRequest RestCreateBranchRequest) (RestBranch, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/branches"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeCreateBranchForRepositoryCall(ctx, requestURL, restCreateBranchRequest)
}

func (a *RepositoryAPIRepository) makeCreateBranchForRepositoryCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestBranch, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPost
	requestUrl := requestURL.String()

    var result RestBranch
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestBranch](&response)
        if err == nil {
            result = response.Body.(RestBranch)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPICreateCommentRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    commitId string
    repositorySlug string
    since *string
    restComment *RestComment
}

    // For a merge commit, a parent can be provided to specify which diff the comments should be on. For a commit range, a sinceId can be provided to specify where the comments should be anchored from.
func (r *RepositoryAPICreateCommentRequest) Since(since string) *RepositoryAPICreateCommentRequest {
    r.since = &since
    return r
}

    // the comment
func (r *RepositoryAPICreateCommentRequest) RestComment(restComment RestComment) *RepositoryAPICreateCommentRequest {
    r.restComment = &restComment
    return r
}

func (r *RepositoryAPICreateCommentRequest) Execute() (RestComment, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.CreateCommentExecute(r)
}

func (a *RepositoryAPIRepository) CreateCommentRequest(ctx context.Context, projectKey string, commitId string, repositorySlug string) RepositoryAPICreateCommentRequest {
    return RepositoryAPICreateCommentRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        commitId: commitId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) CreateCommentExecute(r *RepositoryAPICreateCommentRequest) (RestComment, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(r.commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.since!=nil {
        withUrlQueryParam(requestURL, "since", *r.since)
    }
    return a.makeCreateCommentCall(r.ctx, requestURL, r.restComment)
}

func (a *RepositoryAPIRepository) CreateComment(ctx context.Context, projectKey string, commitId string, repositorySlug string, restComment RestComment, since string) (RestComment, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "since", since)
    return a.makeCreateCommentCall(ctx, requestURL, restComment)
}

func (a *RepositoryAPIRepository) makeCreateCommentCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestComment, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPost
	requestUrl := requestURL.String()

    var result RestComment
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 409 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestComment](&response)
        if err == nil {
            result = response.Body.(RestComment)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPICreateRestrictions1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    restRestrictionRequest *[]RestRestrictionRequest
}

    // The request containing a list of the details of the restrictions to create.
func (r *RepositoryAPICreateRestrictions1Request) RestRestrictionRequest(restRestrictionRequest []RestRestrictionRequest) *RepositoryAPICreateRestrictions1Request {
    r.restRestrictionRequest = &restRestrictionRequest
    return r
}

func (r *RepositoryAPICreateRestrictions1Request) Execute() (RestRefRestriction, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.CreateRestrictions1Execute(r)
}

func (a *RepositoryAPIRepository) CreateRestrictions1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPICreateRestrictions1Request {
    return RepositoryAPICreateRestrictions1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) CreateRestrictions1Execute(r *RepositoryAPICreateRestrictions1Request) (RestRefRestriction, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/branch-permissions/latest/projects/{projectKey}/repos/{repositorySlug}/restrictions"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeCreateRestrictions1Call(r.ctx, requestURL, r.restRestrictionRequest)
}

func (a *RepositoryAPIRepository) CreateRestrictions1(ctx context.Context, projectKey string, repositorySlug string, restRestrictionRequest []RestRestrictionRequest) (RestRefRestriction, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/branch-permissions/latest/projects/{projectKey}/repos/{repositorySlug}/restrictions"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeCreateRestrictions1Call(ctx, requestURL, restRestrictionRequest)
}

func (a *RepositoryAPIRepository) makeCreateRestrictions1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestRefRestriction, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPost
	requestUrl := requestURL.String()

    var result RestRefRestriction
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestRefRestriction](&response)
        if err == nil {
            result = response.Body.(RestRefRestriction)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPICreateTagRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    restGitTagCreateRequest *RestGitTagCreateRequest
}

    // The create git tag request.
func (r *RepositoryAPICreateTagRequest) RestGitTagCreateRequest(restGitTagCreateRequest RestGitTagCreateRequest) *RepositoryAPICreateTagRequest {
    r.restGitTagCreateRequest = &restGitTagCreateRequest
    return r
}

func (r *RepositoryAPICreateTagRequest) Execute() (RestTag, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.CreateTagExecute(r)
}

func (a *RepositoryAPIRepository) CreateTagRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPICreateTagRequest {
    return RepositoryAPICreateTagRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) CreateTagExecute(r *RepositoryAPICreateTagRequest) (RestTag, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/git/latest/projects/{projectKey}/repos/{repositorySlug}/tags"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeCreateTagCall(r.ctx, requestURL, r.restGitTagCreateRequest)
}

func (a *RepositoryAPIRepository) CreateTag(ctx context.Context, projectKey string, repositorySlug string, restGitTagCreateRequest RestGitTagCreateRequest) (RestTag, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/git/latest/projects/{projectKey}/repos/{repositorySlug}/tags"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeCreateTagCall(ctx, requestURL, restGitTagCreateRequest)
}

func (a *RepositoryAPIRepository) makeCreateTagCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestTag, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPost
	requestUrl := requestURL.String()

    var result RestTag
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestTag](&response)
        if err == nil {
            result = response.Body.(RestTag)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPICreateTagForRepositoryRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    restCreateTagRequest *RestCreateTagRequest
}

    // The request to create a tag containing a &lt;strong&gt;name&lt;/strong&gt;, &lt;strong&gt;startPoint&lt;/strong&gt;, and optionally a &lt;strong&gt;message&lt;/strong&gt;
func (r *RepositoryAPICreateTagForRepositoryRequest) RestCreateTagRequest(restCreateTagRequest RestCreateTagRequest) *RepositoryAPICreateTagForRepositoryRequest {
    r.restCreateTagRequest = &restCreateTagRequest
    return r
}

func (r *RepositoryAPICreateTagForRepositoryRequest) Execute() (RestTag, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.CreateTagForRepositoryExecute(r)
}

func (a *RepositoryAPIRepository) CreateTagForRepositoryRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPICreateTagForRepositoryRequest {
    return RepositoryAPICreateTagForRepositoryRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) CreateTagForRepositoryExecute(r *RepositoryAPICreateTagForRepositoryRequest) (RestTag, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/tags"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeCreateTagForRepositoryCall(r.ctx, requestURL, r.restCreateTagRequest)
}

func (a *RepositoryAPIRepository) CreateTagForRepository(ctx context.Context, projectKey string, repositorySlug string, restCreateTagRequest RestCreateTagRequest) (RestTag, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/tags"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeCreateTagForRepositoryCall(ctx, requestURL, restCreateTagRequest)
}

func (a *RepositoryAPIRepository) makeCreateTagForRepositoryCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestTag, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPost
	requestUrl := requestURL.String()

    var result RestTag
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestTag](&response)
        if err == nil {
            result = response.Body.(RestTag)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPICreateWebhook1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    restWebhook *RestWebhook
}

    // The webhook to be created for this repository.
func (r *RepositoryAPICreateWebhook1Request) RestWebhook(restWebhook RestWebhook) *RepositoryAPICreateWebhook1Request {
    r.restWebhook = &restWebhook
    return r
}

func (r *RepositoryAPICreateWebhook1Request) Execute() (RestWebhook, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.CreateWebhook1Execute(r)
}

func (a *RepositoryAPIRepository) CreateWebhook1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPICreateWebhook1Request {
    return RepositoryAPICreateWebhook1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) CreateWebhook1Execute(r *RepositoryAPICreateWebhook1Request) (RestWebhook, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeCreateWebhook1Call(r.ctx, requestURL, r.restWebhook)
}

func (a *RepositoryAPIRepository) CreateWebhook1(ctx context.Context, projectKey string, repositorySlug string, restWebhook RestWebhook) (RestWebhook, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeCreateWebhook1Call(ctx, requestURL, restWebhook)
}

func (a *RepositoryAPIRepository) makeCreateWebhook1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestWebhook, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPost
	requestUrl := requestURL.String()

    var result RestWebhook
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestWebhook](&response)
        if err == nil {
            result = response.Body.(RestWebhook)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIDelete5Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
}

func (r *RepositoryAPIDelete5Request) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.Delete5Execute(r)
}

func (a *RepositoryAPIRepository) Delete5Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIDelete5Request {
    return RepositoryAPIDelete5Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) Delete5Execute(r *RepositoryAPIDelete5Request) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-merge"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDelete5Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) Delete5(ctx context.Context, projectKey string, repositorySlug string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-merge"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDelete5Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeDelete5Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodDelete
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 403 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIDeleteAttachmentRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    attachmentId string
    repositorySlug string
}

func (r *RepositoryAPIDeleteAttachmentRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.DeleteAttachmentExecute(r)
}

func (a *RepositoryAPIRepository) DeleteAttachmentRequest(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) RepositoryAPIDeleteAttachmentRequest {
    return RepositoryAPIDeleteAttachmentRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        attachmentId: attachmentId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) DeleteAttachmentExecute(r *RepositoryAPIDeleteAttachmentRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{attachmentId}", urlUtil.PathEscape(r.attachmentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDeleteAttachmentCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) DeleteAttachment(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{attachmentId}", urlUtil.PathEscape(attachmentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDeleteAttachmentCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeDeleteAttachmentCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodDelete
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIDeleteAttachmentMetadataRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    attachmentId string
    repositorySlug string
}

func (r *RepositoryAPIDeleteAttachmentMetadataRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.DeleteAttachmentMetadataExecute(r)
}

func (a *RepositoryAPIRepository) DeleteAttachmentMetadataRequest(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) RepositoryAPIDeleteAttachmentMetadataRequest {
    return RepositoryAPIDeleteAttachmentMetadataRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        attachmentId: attachmentId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) DeleteAttachmentMetadataExecute(r *RepositoryAPIDeleteAttachmentMetadataRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}/metadata"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{attachmentId}", urlUtil.PathEscape(r.attachmentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDeleteAttachmentMetadataCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) DeleteAttachmentMetadata(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}/metadata"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{attachmentId}", urlUtil.PathEscape(attachmentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDeleteAttachmentMetadataCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeDeleteAttachmentMetadataCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodDelete
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIDeleteAutoDeclineSettings1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
}

func (r *RepositoryAPIDeleteAutoDeclineSettings1Request) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.DeleteAutoDeclineSettings1Execute(r)
}

func (a *RepositoryAPIRepository) DeleteAutoDeclineSettings1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIDeleteAutoDeclineSettings1Request {
    return RepositoryAPIDeleteAutoDeclineSettings1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) DeleteAutoDeclineSettings1Execute(r *RepositoryAPIDeleteAutoDeclineSettings1Request) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-decline"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDeleteAutoDeclineSettings1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) DeleteAutoDeclineSettings1(ctx context.Context, projectKey string, repositorySlug string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-decline"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDeleteAutoDeclineSettings1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeDeleteAutoDeclineSettings1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodDelete
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIDeleteBranchRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    restBranchDeleteRequest *RestBranchDeleteRequest
}

    // Branch delete request
func (r *RepositoryAPIDeleteBranchRequest) RestBranchDeleteRequest(restBranchDeleteRequest RestBranchDeleteRequest) *RepositoryAPIDeleteBranchRequest {
    r.restBranchDeleteRequest = &restBranchDeleteRequest
    return r
}

func (r *RepositoryAPIDeleteBranchRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.DeleteBranchExecute(r)
}

func (a *RepositoryAPIRepository) DeleteBranchRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIDeleteBranchRequest {
    return RepositoryAPIDeleteBranchRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) DeleteBranchExecute(r *RepositoryAPIDeleteBranchRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/branch-utils/latest/projects/{projectKey}/repos/{repositorySlug}/branches"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDeleteBranchCall(r.ctx, requestURL, r.restBranchDeleteRequest)
}

func (a *RepositoryAPIRepository) DeleteBranch(ctx context.Context, projectKey string, repositorySlug string, restBranchDeleteRequest RestBranchDeleteRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/branch-utils/latest/projects/{projectKey}/repos/{repositorySlug}/branches"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDeleteBranchCall(ctx, requestURL, restBranchDeleteRequest)
}

func (a *RepositoryAPIRepository) makeDeleteBranchCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodDelete
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIDeleteCommentRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    commentId string
    commitId string
    repositorySlug string
    version *string
}

    // The expected version of the comment. This must match the server&#39;s version of the comment or the delete will fail. To determine the current version of the comment, the comment should be fetched from the server prior to the delete. Look for the &#39;version&#39; attribute in the returned JSON structure.
func (r *RepositoryAPIDeleteCommentRequest) Version(version string) *RepositoryAPIDeleteCommentRequest {
    r.version = &version
    return r
}

func (r *RepositoryAPIDeleteCommentRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.DeleteCommentExecute(r)
}

func (a *RepositoryAPIRepository) DeleteCommentRequest(ctx context.Context, projectKey string, commentId string, commitId string, repositorySlug string) RepositoryAPIDeleteCommentRequest {
    return RepositoryAPIDeleteCommentRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        commentId: commentId,
        commitId: commitId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) DeleteCommentExecute(r *RepositoryAPIDeleteCommentRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commentId}", urlUtil.PathEscape(r.commentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(r.commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.version!=nil {
        withUrlQueryParam(requestURL, "version", *r.version)
    }
    return a.makeDeleteCommentCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) DeleteComment(ctx context.Context, projectKey string, commentId string, commitId string, repositorySlug string, version string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commentId}", urlUtil.PathEscape(commentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "version", version)
    return a.makeDeleteCommentCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeDeleteCommentCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodDelete
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 409 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIDeleteRepositoryHookRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    hookKey string
    repositorySlug string
}

func (r *RepositoryAPIDeleteRepositoryHookRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.DeleteRepositoryHookExecute(r)
}

func (a *RepositoryAPIRepository) DeleteRepositoryHookRequest(ctx context.Context, projectKey string, hookKey string, repositorySlug string) RepositoryAPIDeleteRepositoryHookRequest {
    return RepositoryAPIDeleteRepositoryHookRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        hookKey: hookKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) DeleteRepositoryHookExecute(r *RepositoryAPIDeleteRepositoryHookRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{hookKey}", urlUtil.PathEscape(r.hookKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDeleteRepositoryHookCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) DeleteRepositoryHook(ctx context.Context, projectKey string, hookKey string, repositorySlug string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{hookKey}", urlUtil.PathEscape(hookKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDeleteRepositoryHookCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeDeleteRepositoryHookCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodDelete
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIDeleteRestriction1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    id string
    repositorySlug string
}

func (r *RepositoryAPIDeleteRestriction1Request) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.DeleteRestriction1Execute(r)
}

func (a *RepositoryAPIRepository) DeleteRestriction1Request(ctx context.Context, projectKey string, id string, repositorySlug string) RepositoryAPIDeleteRestriction1Request {
    return RepositoryAPIDeleteRestriction1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        id: id,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) DeleteRestriction1Execute(r *RepositoryAPIDeleteRestriction1Request) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/branch-permissions/latest/projects/{projectKey}/repos/{repositorySlug}/restrictions/{id}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{id}", urlUtil.PathEscape(r.id))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDeleteRestriction1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) DeleteRestriction1(ctx context.Context, projectKey string, id string, repositorySlug string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/branch-permissions/latest/projects/{projectKey}/repos/{repositorySlug}/restrictions/{id}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{id}", urlUtil.PathEscape(id))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDeleteRestriction1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeDeleteRestriction1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodDelete
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIDeleteTagRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    name string
    repositorySlug string
}

func (r *RepositoryAPIDeleteTagRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.DeleteTagExecute(r)
}

func (a *RepositoryAPIRepository) DeleteTagRequest(ctx context.Context, projectKey string, name string, repositorySlug string) RepositoryAPIDeleteTagRequest {
    return RepositoryAPIDeleteTagRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        name: name,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) DeleteTagExecute(r *RepositoryAPIDeleteTagRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/git/latest/projects/{projectKey}/repos/{repositorySlug}/tags/{name}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{name}", urlUtil.PathEscape(r.name))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDeleteTagCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) DeleteTag(ctx context.Context, projectKey string, name string, repositorySlug string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/git/latest/projects/{projectKey}/repos/{repositorySlug}/tags/{name}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{name}", urlUtil.PathEscape(name))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDeleteTagCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeDeleteTagCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodDelete
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIDeleteWebhook1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    webhookId string
    repositorySlug string
}

func (r *RepositoryAPIDeleteWebhook1Request) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.DeleteWebhook1Execute(r)
}

func (a *RepositoryAPIRepository) DeleteWebhook1Request(ctx context.Context, projectKey string, webhookId string, repositorySlug string) RepositoryAPIDeleteWebhook1Request {
    return RepositoryAPIDeleteWebhook1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        webhookId: webhookId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) DeleteWebhook1Execute(r *RepositoryAPIDeleteWebhook1Request) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{webhookId}", urlUtil.PathEscape(r.webhookId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDeleteWebhook1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) DeleteWebhook1(ctx context.Context, projectKey string, webhookId string, repositorySlug string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{webhookId}", urlUtil.PathEscape(webhookId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDeleteWebhook1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeDeleteWebhook1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodDelete
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIDisableHook1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    hookKey string
    repositorySlug string
}

func (r *RepositoryAPIDisableHook1Request) Execute() (RestRepositoryHook, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.DisableHook1Execute(r)
}

func (a *RepositoryAPIRepository) DisableHook1Request(ctx context.Context, projectKey string, hookKey string, repositorySlug string) RepositoryAPIDisableHook1Request {
    return RepositoryAPIDisableHook1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        hookKey: hookKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) DisableHook1Execute(r *RepositoryAPIDisableHook1Request) (RestRepositoryHook, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/enabled"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{hookKey}", urlUtil.PathEscape(r.hookKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDisableHook1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) DisableHook1(ctx context.Context, projectKey string, hookKey string, repositorySlug string) (RestRepositoryHook, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/enabled"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{hookKey}", urlUtil.PathEscape(hookKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeDisableHook1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeDisableHook1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestRepositoryHook, aurestclientapi.ParsedResponse, error) {
	method := http.MethodDelete
	requestUrl := requestURL.String()

    var result RestRepositoryHook
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestRepositoryHook](&response)
        if err == nil {
            result = response.Body.(RestRepositoryHook)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIEditFileRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    path string
    projectKey string
    repositorySlug string
    exampleMultipartFormData *ExampleMultipartFormData
}

    // The multipart form data containing the file
func (r *RepositoryAPIEditFileRequest) ExampleMultipartFormData(exampleMultipartFormData ExampleMultipartFormData) *RepositoryAPIEditFileRequest {
    r.exampleMultipartFormData = &exampleMultipartFormData
    return r
}

func (r *RepositoryAPIEditFileRequest) Execute() (RestCommit, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.EditFileExecute(r)
}

func (a *RepositoryAPIRepository) EditFileRequest(ctx context.Context, path string, projectKey string, repositorySlug string) RepositoryAPIEditFileRequest {
    return RepositoryAPIEditFileRequest{
        ApiService: a,
        ctx: ctx,
        path: path,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) EditFileExecute(r *RepositoryAPIEditFileRequest) (RestCommit, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/browse/{path}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{path}", urlUtil.PathEscape(r.path))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeEditFileCall(r.ctx, requestURL, r.exampleMultipartFormData)
}

func (a *RepositoryAPIRepository) EditFile(ctx context.Context, path string, projectKey string, repositorySlug string, exampleMultipartFormData ExampleMultipartFormData) (RestCommit, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/browse/{path}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{path}", urlUtil.PathEscape(path))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeEditFileCall(ctx, requestURL, exampleMultipartFormData)
}

func (a *RepositoryAPIRepository) makeEditFileCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestCommit, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPut
	requestUrl := requestURL.String()

    var result RestCommit
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 403 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 409 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestCommit](&response)
        if err == nil {
            result = response.Body.(RestCommit)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIEnableHook1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    hookKey string
    repositorySlug string
    contentLength *string
}

    // The content length.
func (r *RepositoryAPIEnableHook1Request) ContentLength(contentLength string) *RepositoryAPIEnableHook1Request {
    r.contentLength = &contentLength
    return r
}

func (r *RepositoryAPIEnableHook1Request) Execute() (RestRepositoryHook, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.EnableHook1Execute(r)
}

func (a *RepositoryAPIRepository) EnableHook1Request(ctx context.Context, projectKey string, hookKey string, repositorySlug string) RepositoryAPIEnableHook1Request {
    return RepositoryAPIEnableHook1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        hookKey: hookKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) EnableHook1Execute(r *RepositoryAPIEnableHook1Request) (RestRepositoryHook, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/enabled"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{hookKey}", urlUtil.PathEscape(r.hookKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeEnableHook1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) EnableHook1(ctx context.Context, projectKey string, hookKey string, repositorySlug string) (RestRepositoryHook, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/enabled"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{hookKey}", urlUtil.PathEscape(hookKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeEnableHook1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeEnableHook1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestRepositoryHook, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPut
	requestUrl := requestURL.String()

    var result RestRepositoryHook
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestRepositoryHook](&response)
        if err == nil {
            result = response.Body.(RestRepositoryHook)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIFindBranchesRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    filterText *string
    start *float32
    limit *float32
}

    // (optional) Partial match for a ref ID to filter minimal refs for
func (r *RepositoryAPIFindBranchesRequest) FilterText(filterText string) *RepositoryAPIFindBranchesRequest {
    r.filterText = &filterText
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIFindBranchesRequest) Start(start float32) *RepositoryAPIFindBranchesRequest {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIFindBranchesRequest) Limit(limit float32) *RepositoryAPIFindBranchesRequest {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIFindBranchesRequest) Execute() (FindByCommit200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.FindBranchesExecute(r)
}

func (a *RepositoryAPIRepository) FindBranchesRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIFindBranchesRequest {
    return RepositoryAPIFindBranchesRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) FindBranchesExecute(r *RepositoryAPIFindBranchesRequest) (FindByCommit200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/ref-change-activities/branches"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.filterText!=nil {
        withUrlQueryParam(requestURL, "filterText", *r.filterText)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeFindBranchesCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) FindBranches(ctx context.Context, projectKey string, repositorySlug string, filterText string, start float32, limit float32) (FindByCommit200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/ref-change-activities/branches"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "filterText", filterText)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeFindBranchesCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeFindBranchesCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (FindByCommit200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result FindByCommit200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[FindByCommit200Response](&response)
        if err == nil {
            result = response.Body.(FindByCommit200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIFindByCommitRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    commitId string
    repositorySlug string
    start *float32
    limit *float32
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIFindByCommitRequest) Start(start float32) *RepositoryAPIFindByCommitRequest {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIFindByCommitRequest) Limit(limit float32) *RepositoryAPIFindByCommitRequest {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIFindByCommitRequest) Execute() (FindByCommit200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.FindByCommitExecute(r)
}

func (a *RepositoryAPIRepository) FindByCommitRequest(ctx context.Context, projectKey string, commitId string, repositorySlug string) RepositoryAPIFindByCommitRequest {
    return RepositoryAPIFindByCommitRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        commitId: commitId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) FindByCommitExecute(r *RepositoryAPIFindByCommitRequest) (FindByCommit200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/branch-utils/latest/projects/{projectKey}/repos/{repositorySlug}/branches/info/{commitId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(r.commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeFindByCommitCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) FindByCommit(ctx context.Context, projectKey string, commitId string, repositorySlug string, start float32, limit float32) (FindByCommit200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/branch-utils/latest/projects/{projectKey}/repos/{repositorySlug}/branches/info/{commitId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeFindByCommitCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeFindByCommitCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (FindByCommit200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result FindByCommit200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 500 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[FindByCommit200Response](&response)
        if err == nil {
            result = response.Body.(FindByCommit200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIFindWebhooks1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    event *string
    statistics *bool
}

    // List of &lt;code&gt;com.atlassian.webhooks.WebhookEvent&lt;/code&gt; IDs to filter for
func (r *RepositoryAPIFindWebhooks1Request) Event(event string) *RepositoryAPIFindWebhooks1Request {
    r.event = &event
    return r
}

    // &lt;code&gt;true&lt;/code&gt; if statistics should be provided for all found webhooks
func (r *RepositoryAPIFindWebhooks1Request) Statistics(statistics bool) *RepositoryAPIFindWebhooks1Request {
    r.statistics = &statistics
    return r
}

func (r *RepositoryAPIFindWebhooks1Request) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.FindWebhooks1Execute(r)
}

func (a *RepositoryAPIRepository) FindWebhooks1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIFindWebhooks1Request {
    return RepositoryAPIFindWebhooks1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) FindWebhooks1Execute(r *RepositoryAPIFindWebhooks1Request) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.event!=nil {
        withUrlQueryParam(requestURL, "event", *r.event)
    }
    if r.statistics!=nil {
        withUrlQueryParam(requestURL, "statistics", parameterValueToString(*r.statistics))
    }
    return a.makeFindWebhooks1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) FindWebhooks1(ctx context.Context, projectKey string, repositorySlug string, event string, statistics bool) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "event", event)
    withUrlQueryParam(requestURL, "statistics", parameterValueToString(statistics))
    return a.makeFindWebhooks1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeFindWebhooks1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIGet5Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
}

func (r *RepositoryAPIGet5Request) Execute() (RestAutoMergeRestrictedSettings, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.Get5Execute(r)
}

func (a *RepositoryAPIRepository) Get5Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGet5Request {
    return RepositoryAPIGet5Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) Get5Execute(r *RepositoryAPIGet5Request) (RestAutoMergeRestrictedSettings, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-merge"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGet5Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) Get5(ctx context.Context, projectKey string, repositorySlug string) (RestAutoMergeRestrictedSettings, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-merge"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGet5Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGet5Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestAutoMergeRestrictedSettings, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result RestAutoMergeRestrictedSettings
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestAutoMergeRestrictedSettings](&response)
        if err == nil {
            result = response.Body.(RestAutoMergeRestrictedSettings)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetAllLabelsForRepositoryRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
}

func (r *RepositoryAPIGetAllLabelsForRepositoryRequest) Execute() (RestLabel, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetAllLabelsForRepositoryExecute(r)
}

func (a *RepositoryAPIRepository) GetAllLabelsForRepositoryRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetAllLabelsForRepositoryRequest {
    return RepositoryAPIGetAllLabelsForRepositoryRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetAllLabelsForRepositoryExecute(r *RepositoryAPIGetAllLabelsForRepositoryRequest) (RestLabel, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/labels"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetAllLabelsForRepositoryCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetAllLabelsForRepository(ctx context.Context, projectKey string, repositorySlug string) (RestLabel, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/labels"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetAllLabelsForRepositoryCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetAllLabelsForRepositoryCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestLabel, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result RestLabel
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestLabel](&response)
        if err == nil {
            result = response.Body.(RestLabel)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetArchiveRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    path *string
    filename *string
    at *string
    prefix *string
    format *string
}

    // Paths to include in the streamed archive; may be repeated to include multiple paths
func (r *RepositoryAPIGetArchiveRequest) Path(path string) *RepositoryAPIGetArchiveRequest {
    r.path = &path
    return r
}

    // A filename to include the \&quot;Content-Disposition\&quot; header
func (r *RepositoryAPIGetArchiveRequest) Filename(filename string) *RepositoryAPIGetArchiveRequest {
    r.filename = &filename
    return r
}

    // The commit to stream an archive of; if not supplied, an archive of the default branch is streamed
func (r *RepositoryAPIGetArchiveRequest) At(at string) *RepositoryAPIGetArchiveRequest {
    r.at = &at
    return r
}

    // A prefix to apply to all entries in the streamed archive; if the supplied prefix does not end with a trailing /, one will be added automatically
func (r *RepositoryAPIGetArchiveRequest) Prefix(prefix string) *RepositoryAPIGetArchiveRequest {
    r.prefix = &prefix
    return r
}

    // The format to stream the archive in; must be one of: zip, tar, tar.gz or tgz
func (r *RepositoryAPIGetArchiveRequest) Format(format string) *RepositoryAPIGetArchiveRequest {
    r.format = &format
    return r
}

func (r *RepositoryAPIGetArchiveRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetArchiveExecute(r)
}

func (a *RepositoryAPIRepository) GetArchiveRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetArchiveRequest {
    return RepositoryAPIGetArchiveRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetArchiveExecute(r *RepositoryAPIGetArchiveRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/archive"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.path!=nil {
        withUrlQueryParam(requestURL, "path", *r.path)
    }
    if r.filename!=nil {
        withUrlQueryParam(requestURL, "filename", *r.filename)
    }
    if r.at!=nil {
        withUrlQueryParam(requestURL, "at", *r.at)
    }
    if r.prefix!=nil {
        withUrlQueryParam(requestURL, "prefix", *r.prefix)
    }
    if r.format!=nil {
        withUrlQueryParam(requestURL, "format", *r.format)
    }
    return a.makeGetArchiveCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetArchive(ctx context.Context, projectKey string, repositorySlug string, path string, filename string, at string, prefix string, format string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/archive"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "path", path)
    withUrlQueryParam(requestURL, "filename", filename)
    withUrlQueryParam(requestURL, "at", at)
    withUrlQueryParam(requestURL, "prefix", prefix)
    withUrlQueryParam(requestURL, "format", format)
    return a.makeGetArchiveCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetArchiveCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIGetAttachmentRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    attachmentId string
    repositorySlug string
    userAgent *string
    range_ *string
}

func (r *RepositoryAPIGetAttachmentRequest) UserAgent(userAgent string) *RepositoryAPIGetAttachmentRequest {
    r.userAgent = &userAgent
    return r
}

func (r *RepositoryAPIGetAttachmentRequest) Range_(range_ string) *RepositoryAPIGetAttachmentRequest {
    r.range_ = &range_
    return r
}

func (r *RepositoryAPIGetAttachmentRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetAttachmentExecute(r)
}

func (a *RepositoryAPIRepository) GetAttachmentRequest(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) RepositoryAPIGetAttachmentRequest {
    return RepositoryAPIGetAttachmentRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        attachmentId: attachmentId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetAttachmentExecute(r *RepositoryAPIGetAttachmentRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{attachmentId}", urlUtil.PathEscape(r.attachmentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetAttachmentCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetAttachment(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{attachmentId}", urlUtil.PathEscape(attachmentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetAttachmentCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetAttachmentCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIGetAttachmentMetadataRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    attachmentId string
    repositorySlug string
}

func (r *RepositoryAPIGetAttachmentMetadataRequest) Execute() (RestAttachmentMetadata, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetAttachmentMetadataExecute(r)
}

func (a *RepositoryAPIRepository) GetAttachmentMetadataRequest(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) RepositoryAPIGetAttachmentMetadataRequest {
    return RepositoryAPIGetAttachmentMetadataRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        attachmentId: attachmentId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetAttachmentMetadataExecute(r *RepositoryAPIGetAttachmentMetadataRequest) (RestAttachmentMetadata, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}/metadata"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{attachmentId}", urlUtil.PathEscape(r.attachmentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetAttachmentMetadataCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetAttachmentMetadata(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) (RestAttachmentMetadata, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}/metadata"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{attachmentId}", urlUtil.PathEscape(attachmentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetAttachmentMetadataCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetAttachmentMetadataCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestAttachmentMetadata, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result RestAttachmentMetadata
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestAttachmentMetadata](&response)
        if err == nil {
            result = response.Body.(RestAttachmentMetadata)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetAutoDeclineSettings1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
}

func (r *RepositoryAPIGetAutoDeclineSettings1Request) Execute() (RestAutoDeclineSettings, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetAutoDeclineSettings1Execute(r)
}

func (a *RepositoryAPIRepository) GetAutoDeclineSettings1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetAutoDeclineSettings1Request {
    return RepositoryAPIGetAutoDeclineSettings1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetAutoDeclineSettings1Execute(r *RepositoryAPIGetAutoDeclineSettings1Request) (RestAutoDeclineSettings, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-decline"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetAutoDeclineSettings1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetAutoDeclineSettings1(ctx context.Context, projectKey string, repositorySlug string) (RestAutoDeclineSettings, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-decline"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetAutoDeclineSettings1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetAutoDeclineSettings1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestAutoDeclineSettings, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result RestAutoDeclineSettings
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestAutoDeclineSettings](&response)
        if err == nil {
            result = response.Body.(RestAutoDeclineSettings)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetBranchesRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    boostMatches *bool
    orderBy *string
    details *bool
    filterText *string
    base *string
    start *float32
    limit *float32
}

    // Controls whether exact and prefix matches will be boosted to the top
func (r *RepositoryAPIGetBranchesRequest) BoostMatches(boostMatches bool) *RepositoryAPIGetBranchesRequest {
    r.boostMatches = &boostMatches
    return r
}

    // Ordering of refs either ALPHABETICAL (by name) or MODIFICATION (last updated)
func (r *RepositoryAPIGetBranchesRequest) OrderBy(orderBy string) *RepositoryAPIGetBranchesRequest {
    r.orderBy = &orderBy
    return r
}

    // Whether to retrieve plugin-provided metadata about each branch
func (r *RepositoryAPIGetBranchesRequest) Details(details bool) *RepositoryAPIGetBranchesRequest {
    r.details = &details
    return r
}

    // The text to match on
func (r *RepositoryAPIGetBranchesRequest) FilterText(filterText string) *RepositoryAPIGetBranchesRequest {
    r.filterText = &filterText
    return r
}

    // Base branch or tag to compare each branch to (for the metadata providers that uses that information
func (r *RepositoryAPIGetBranchesRequest) Base(base string) *RepositoryAPIGetBranchesRequest {
    r.base = &base
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIGetBranchesRequest) Start(start float32) *RepositoryAPIGetBranchesRequest {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIGetBranchesRequest) Limit(limit float32) *RepositoryAPIGetBranchesRequest {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIGetBranchesRequest) Execute() (GetBranches200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetBranchesExecute(r)
}

func (a *RepositoryAPIRepository) GetBranchesRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetBranchesRequest {
    return RepositoryAPIGetBranchesRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetBranchesExecute(r *RepositoryAPIGetBranchesRequest) (GetBranches200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/branches"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.boostMatches!=nil {
        withUrlQueryParam(requestURL, "boostMatches", parameterValueToString(*r.boostMatches))
    }
    if r.orderBy!=nil {
        withUrlQueryParam(requestURL, "orderBy", *r.orderBy)
    }
    if r.details!=nil {
        withUrlQueryParam(requestURL, "details", parameterValueToString(*r.details))
    }
    if r.filterText!=nil {
        withUrlQueryParam(requestURL, "filterText", *r.filterText)
    }
    if r.base!=nil {
        withUrlQueryParam(requestURL, "base", *r.base)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeGetBranchesCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetBranches(ctx context.Context, projectKey string, repositorySlug string, boostMatches bool, orderBy string, details bool, filterText string, base string, start float32, limit float32) (GetBranches200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/branches"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "boostMatches", parameterValueToString(boostMatches))
    withUrlQueryParam(requestURL, "orderBy", orderBy)
    withUrlQueryParam(requestURL, "details", parameterValueToString(details))
    withUrlQueryParam(requestURL, "filterText", filterText)
    withUrlQueryParam(requestURL, "base", base)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeGetBranchesCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetBranchesCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (GetBranches200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result GetBranches200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[GetBranches200Response](&response)
        if err == nil {
            result = response.Body.(GetBranches200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetChangesRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    commitId string
    repositorySlug string
    withComments *string
    since *string
    start *float32
    limit *float32
}

    // &lt;code&gt;true&lt;/code&gt; to apply comment counts in the changes (the default); otherwise, &lt;code&gt;false&lt;/code&gt; to stream changes without comment counts
func (r *RepositoryAPIGetChangesRequest) WithComments(withComments string) *RepositoryAPIGetChangesRequest {
    r.withComments = &withComments
    return r
}

    // The commit to which &lt;code&gt;until&lt;/code&gt; should be compared to produce a page of changes. If not specified the commit&#39;s first parent is assumed (if one exists)
func (r *RepositoryAPIGetChangesRequest) Since(since string) *RepositoryAPIGetChangesRequest {
    r.since = &since
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIGetChangesRequest) Start(start float32) *RepositoryAPIGetChangesRequest {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIGetChangesRequest) Limit(limit float32) *RepositoryAPIGetChangesRequest {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIGetChangesRequest) Execute() (GetChanges1200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetChangesExecute(r)
}

func (a *RepositoryAPIRepository) GetChangesRequest(ctx context.Context, projectKey string, commitId string, repositorySlug string) RepositoryAPIGetChangesRequest {
    return RepositoryAPIGetChangesRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        commitId: commitId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetChangesExecute(r *RepositoryAPIGetChangesRequest) (GetChanges1200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/changes"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(r.commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.withComments!=nil {
        withUrlQueryParam(requestURL, "withComments", *r.withComments)
    }
    if r.since!=nil {
        withUrlQueryParam(requestURL, "since", *r.since)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeGetChangesCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetChanges(ctx context.Context, projectKey string, commitId string, repositorySlug string, withComments string, since string, start float32, limit float32) (GetChanges1200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/changes"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "withComments", withComments)
    withUrlQueryParam(requestURL, "since", since)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeGetChangesCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetChangesCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (GetChanges1200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result GetChanges1200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[GetChanges1200Response](&response)
        if err == nil {
            result = response.Body.(GetChanges1200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetChanges1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    until *string
    since *string
    start *float32
    limit *float32
}

    // The commit to retrieve changes for
func (r *RepositoryAPIGetChanges1Request) Until(until string) *RepositoryAPIGetChanges1Request {
    r.until = &until
    return r
}

    // The commit to which &lt;code&gt;until&lt;/code&gt; should be compared to produce a page of changes. If not specified the commit&#39;s first parent is assumed (if one exists)
func (r *RepositoryAPIGetChanges1Request) Since(since string) *RepositoryAPIGetChanges1Request {
    r.since = &since
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIGetChanges1Request) Start(start float32) *RepositoryAPIGetChanges1Request {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIGetChanges1Request) Limit(limit float32) *RepositoryAPIGetChanges1Request {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIGetChanges1Request) Execute() (GetChanges1200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetChanges1Execute(r)
}

func (a *RepositoryAPIRepository) GetChanges1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetChanges1Request {
    return RepositoryAPIGetChanges1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetChanges1Execute(r *RepositoryAPIGetChanges1Request) (GetChanges1200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/changes"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.until!=nil {
        withUrlQueryParam(requestURL, "until", *r.until)
    }
    if r.since!=nil {
        withUrlQueryParam(requestURL, "since", *r.since)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeGetChanges1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetChanges1(ctx context.Context, projectKey string, repositorySlug string, until string, since string, start float32, limit float32) (GetChanges1200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/changes"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "until", until)
    withUrlQueryParam(requestURL, "since", since)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeGetChanges1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetChanges1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (GetChanges1200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result GetChanges1200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[GetChanges1200Response](&response)
        if err == nil {
            result = response.Body.(GetChanges1200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetCommentRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    commentId string
    commitId string
    repositorySlug string
}

func (r *RepositoryAPIGetCommentRequest) Execute() (RestComment, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetCommentExecute(r)
}

func (a *RepositoryAPIRepository) GetCommentRequest(ctx context.Context, projectKey string, commentId string, commitId string, repositorySlug string) RepositoryAPIGetCommentRequest {
    return RepositoryAPIGetCommentRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        commentId: commentId,
        commitId: commitId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetCommentExecute(r *RepositoryAPIGetCommentRequest) (RestComment, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commentId}", urlUtil.PathEscape(r.commentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(r.commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetCommentCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetComment(ctx context.Context, projectKey string, commentId string, commitId string, repositorySlug string) (RestComment, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commentId}", urlUtil.PathEscape(commentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetCommentCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetCommentCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestComment, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result RestComment
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestComment](&response)
        if err == nil {
            result = response.Body.(RestComment)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetCommentsRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    commitId string
    repositorySlug string
    path *string
    since *string
    start *float32
    limit *float32
}

    // The path to the file on which comments were made
func (r *RepositoryAPIGetCommentsRequest) Path(path string) *RepositoryAPIGetCommentsRequest {
    r.path = &path
    return r
}

    // For a merge commit, a parent can be provided to specify which diff the comments are on. For a commit range, a sinceId can be provided to specify where the comments are anchored from.
func (r *RepositoryAPIGetCommentsRequest) Since(since string) *RepositoryAPIGetCommentsRequest {
    r.since = &since
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIGetCommentsRequest) Start(start float32) *RepositoryAPIGetCommentsRequest {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIGetCommentsRequest) Limit(limit float32) *RepositoryAPIGetCommentsRequest {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIGetCommentsRequest) Execute() (GetComments200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetCommentsExecute(r)
}

func (a *RepositoryAPIRepository) GetCommentsRequest(ctx context.Context, projectKey string, commitId string, repositorySlug string) RepositoryAPIGetCommentsRequest {
    return RepositoryAPIGetCommentsRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        commitId: commitId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetCommentsExecute(r *RepositoryAPIGetCommentsRequest) (GetComments200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(r.commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.path!=nil {
        withUrlQueryParam(requestURL, "path", *r.path)
    }
    if r.since!=nil {
        withUrlQueryParam(requestURL, "since", *r.since)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeGetCommentsCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetComments(ctx context.Context, projectKey string, commitId string, repositorySlug string, path string, since string, start float32, limit float32) (GetComments200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "path", path)
    withUrlQueryParam(requestURL, "since", since)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeGetCommentsCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetCommentsCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (GetComments200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result GetComments200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[GetComments200Response](&response)
        if err == nil {
            result = response.Body.(GetComments200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetCommitRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    commitId string
    repositorySlug string
    path *string
}

    // An optional path to filter the commit by. If supplied the details returned &lt;i&gt;may not&lt;/i&gt; be for the specified commit. Instead, starting from the specified commit, they will be the details for the first commit affecting the specified path.
func (r *RepositoryAPIGetCommitRequest) Path(path string) *RepositoryAPIGetCommitRequest {
    r.path = &path
    return r
}

func (r *RepositoryAPIGetCommitRequest) Execute() (RestCommit, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetCommitExecute(r)
}

func (a *RepositoryAPIRepository) GetCommitRequest(ctx context.Context, projectKey string, commitId string, repositorySlug string) RepositoryAPIGetCommitRequest {
    return RepositoryAPIGetCommitRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        commitId: commitId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetCommitExecute(r *RepositoryAPIGetCommitRequest) (RestCommit, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(r.commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.path!=nil {
        withUrlQueryParam(requestURL, "path", *r.path)
    }
    return a.makeGetCommitCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetCommit(ctx context.Context, projectKey string, commitId string, repositorySlug string, path string) (RestCommit, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "path", path)
    return a.makeGetCommitCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetCommitCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestCommit, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result RestCommit
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestCommit](&response)
        if err == nil {
            result = response.Body.(RestCommit)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetCommitsRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    avatarScheme *string
    path *string
    withCounts *string
    followRenames *string
    until *string
    avatarSize *string
    since *string
    merges *string
    ignoreMissing *string
    start *float32
    limit *float32
}

    // The desired scheme for the avatar URL. If the parameter is not present URLs will use the same scheme as this request
func (r *RepositoryAPIGetCommitsRequest) AvatarScheme(avatarScheme string) *RepositoryAPIGetCommitsRequest {
    r.avatarScheme = &avatarScheme
    return r
}

    // An optional path to filter commits by
func (r *RepositoryAPIGetCommitsRequest) Path(path string) *RepositoryAPIGetCommitsRequest {
    r.path = &path
    return r
}

    // Optionally include the total number of commits and total number of unique authors
func (r *RepositoryAPIGetCommitsRequest) WithCounts(withCounts string) *RepositoryAPIGetCommitsRequest {
    r.withCounts = &withCounts
    return r
}

    // If &lt;code&gt;true&lt;/code&gt;, the commit history of the specified file will be followed past renames. Only valid for a path to a single file.
func (r *RepositoryAPIGetCommitsRequest) FollowRenames(followRenames string) *RepositoryAPIGetCommitsRequest {
    r.followRenames = &followRenames
    return r
}

    // The commit ID (SHA1) or ref (inclusively) to retrieve commits before
func (r *RepositoryAPIGetCommitsRequest) Until(until string) *RepositoryAPIGetCommitsRequest {
    r.until = &until
    return r
}

    // If present the service adds avatar URLs for commit authors. Should be an integer specifying the desired size in pixels. If the parameter is not present, avatar URLs will not be set
func (r *RepositoryAPIGetCommitsRequest) AvatarSize(avatarSize string) *RepositoryAPIGetCommitsRequest {
    r.avatarSize = &avatarSize
    return r
}

    // The commit ID or ref (exclusively) to retrieve commits after
func (r *RepositoryAPIGetCommitsRequest) Since(since string) *RepositoryAPIGetCommitsRequest {
    r.since = &since
    return r
}

    // If present, controls how merge commits should be filtered. Can be either &lt;code&gt;exclude&lt;/code&gt;, to exclude merge commits, &lt;code&gt;include&lt;/code&gt;, to include both merge commits and non-merge commits or &lt;code&gt;only&lt;/code&gt;, to only return merge commits.
func (r *RepositoryAPIGetCommitsRequest) Merges(merges string) *RepositoryAPIGetCommitsRequest {
    r.merges = &merges
    return r
}

    // &lt;code&gt;true&lt;/code&gt; to ignore missing commits, &lt;code&gt;false&lt;/code&gt; otherwise
func (r *RepositoryAPIGetCommitsRequest) IgnoreMissing(ignoreMissing string) *RepositoryAPIGetCommitsRequest {
    r.ignoreMissing = &ignoreMissing
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIGetCommitsRequest) Start(start float32) *RepositoryAPIGetCommitsRequest {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIGetCommitsRequest) Limit(limit float32) *RepositoryAPIGetCommitsRequest {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIGetCommitsRequest) Execute() (GetCommits200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetCommitsExecute(r)
}

func (a *RepositoryAPIRepository) GetCommitsRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetCommitsRequest {
    return RepositoryAPIGetCommitsRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetCommitsExecute(r *RepositoryAPIGetCommitsRequest) (GetCommits200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.avatarScheme!=nil {
        withUrlQueryParam(requestURL, "avatarScheme", *r.avatarScheme)
    }
    if r.path!=nil {
        withUrlQueryParam(requestURL, "path", *r.path)
    }
    if r.withCounts!=nil {
        withUrlQueryParam(requestURL, "withCounts", *r.withCounts)
    }
    if r.followRenames!=nil {
        withUrlQueryParam(requestURL, "followRenames", *r.followRenames)
    }
    if r.until!=nil {
        withUrlQueryParam(requestURL, "until", *r.until)
    }
    if r.avatarSize!=nil {
        withUrlQueryParam(requestURL, "avatarSize", *r.avatarSize)
    }
    if r.since!=nil {
        withUrlQueryParam(requestURL, "since", *r.since)
    }
    if r.merges!=nil {
        withUrlQueryParam(requestURL, "merges", *r.merges)
    }
    if r.ignoreMissing!=nil {
        withUrlQueryParam(requestURL, "ignoreMissing", *r.ignoreMissing)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeGetCommitsCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetCommits(ctx context.Context, projectKey string, repositorySlug string, avatarScheme string, path string, withCounts string, followRenames string, until string, avatarSize string, since string, merges string, ignoreMissing string, start float32, limit float32) (GetCommits200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "avatarScheme", avatarScheme)
    withUrlQueryParam(requestURL, "path", path)
    withUrlQueryParam(requestURL, "withCounts", withCounts)
    withUrlQueryParam(requestURL, "followRenames", followRenames)
    withUrlQueryParam(requestURL, "until", until)
    withUrlQueryParam(requestURL, "avatarSize", avatarSize)
    withUrlQueryParam(requestURL, "since", since)
    withUrlQueryParam(requestURL, "merges", merges)
    withUrlQueryParam(requestURL, "ignoreMissing", ignoreMissing)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeGetCommitsCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetCommitsCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (GetCommits200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result GetCommits200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[GetCommits200Response](&response)
        if err == nil {
            result = response.Body.(GetCommits200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetConfigurations1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    start *float32
    limit *float32
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIGetConfigurations1Request) Start(start float32) *RepositoryAPIGetConfigurations1Request {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIGetConfigurations1Request) Limit(limit float32) *RepositoryAPIGetConfigurations1Request {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIGetConfigurations1Request) Execute() (GetConfigurations200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetConfigurations1Execute(r)
}

func (a *RepositoryAPIRepository) GetConfigurations1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetConfigurations1Request {
    return RepositoryAPIGetConfigurations1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetConfigurations1Execute(r *RepositoryAPIGetConfigurations1Request) (GetConfigurations200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/hook-scripts"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeGetConfigurations1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetConfigurations1(ctx context.Context, projectKey string, repositorySlug string, start float32, limit float32) (GetConfigurations200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/hook-scripts"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeGetConfigurations1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetConfigurations1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (GetConfigurations200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result GetConfigurations200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[GetConfigurations200Response](&response)
        if err == nil {
            result = response.Body.(GetConfigurations200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetContentRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    noContent *string
    at *string
    size *string
    blame *string
    type_ *string
}

    // If blame&amp;amp;noContent only the blame is retrieved instead of the contents
func (r *RepositoryAPIGetContentRequest) NoContent(noContent string) *RepositoryAPIGetContentRequest {
    r.noContent = &noContent
    return r
}

    // The commit ID or ref to retrieve the content for
func (r *RepositoryAPIGetContentRequest) At(at string) *RepositoryAPIGetContentRequest {
    r.at = &at
    return r
}

    // If true only the size will be returned for the file path instead of the contents
func (r *RepositoryAPIGetContentRequest) Size(size string) *RepositoryAPIGetContentRequest {
    r.size = &size
    return r
}

    // If present and not equal to &#39;false&#39;, the blame will be returned for the file as well
func (r *RepositoryAPIGetContentRequest) Blame(blame string) *RepositoryAPIGetContentRequest {
    r.blame = &blame
    return r
}

    // If true only the type will be returned for the file path instead of the contents
func (r *RepositoryAPIGetContentRequest) Type_(type_ string) *RepositoryAPIGetContentRequest {
    r.type_ = &type_
    return r
}

func (r *RepositoryAPIGetContentRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetContentExecute(r)
}

func (a *RepositoryAPIRepository) GetContentRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetContentRequest {
    return RepositoryAPIGetContentRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetContentExecute(r *RepositoryAPIGetContentRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/browse"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.noContent!=nil {
        withUrlQueryParam(requestURL, "noContent", *r.noContent)
    }
    if r.at!=nil {
        withUrlQueryParam(requestURL, "at", *r.at)
    }
    if r.size!=nil {
        withUrlQueryParam(requestURL, "size", *r.size)
    }
    if r.blame!=nil {
        withUrlQueryParam(requestURL, "blame", *r.blame)
    }
    if r.type_!=nil {
        withUrlQueryParam(requestURL, "type", *r.type_)
    }
    return a.makeGetContentCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetContent(ctx context.Context, projectKey string, repositorySlug string, noContent string, at string, size string, blame string, type_ string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/browse"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "noContent", noContent)
    withUrlQueryParam(requestURL, "at", at)
    withUrlQueryParam(requestURL, "size", size)
    withUrlQueryParam(requestURL, "blame", blame)
    withUrlQueryParam(requestURL, "type", type_)
    return a.makeGetContentCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetContentCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIGetContent1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    path string
    projectKey string
    repositorySlug string
    noContent *string
    at *string
    size *string
    blame *string
    type_ *string
}

    // If blame&amp;amp;noContent only the blame is retrieved instead of the contents
func (r *RepositoryAPIGetContent1Request) NoContent(noContent string) *RepositoryAPIGetContent1Request {
    r.noContent = &noContent
    return r
}

    // The commit ID or ref to retrieve the content for
func (r *RepositoryAPIGetContent1Request) At(at string) *RepositoryAPIGetContent1Request {
    r.at = &at
    return r
}

    // If true only the size will be returned for the file path instead of the contents
func (r *RepositoryAPIGetContent1Request) Size(size string) *RepositoryAPIGetContent1Request {
    r.size = &size
    return r
}

    // If present and not equal to &#39;false&#39;, the blame will be returned for the file as well
func (r *RepositoryAPIGetContent1Request) Blame(blame string) *RepositoryAPIGetContent1Request {
    r.blame = &blame
    return r
}

    // If true only the type will be returned for the file path instead of the contents
func (r *RepositoryAPIGetContent1Request) Type_(type_ string) *RepositoryAPIGetContent1Request {
    r.type_ = &type_
    return r
}

func (r *RepositoryAPIGetContent1Request) Execute() (GetContent1200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetContent1Execute(r)
}

func (a *RepositoryAPIRepository) GetContent1Request(ctx context.Context, path string, projectKey string, repositorySlug string) RepositoryAPIGetContent1Request {
    return RepositoryAPIGetContent1Request{
        ApiService: a,
        ctx: ctx,
        path: path,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetContent1Execute(r *RepositoryAPIGetContent1Request) (GetContent1200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/browse/{path}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{path}", urlUtil.PathEscape(r.path))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.noContent!=nil {
        withUrlQueryParam(requestURL, "noContent", *r.noContent)
    }
    if r.at!=nil {
        withUrlQueryParam(requestURL, "at", *r.at)
    }
    if r.size!=nil {
        withUrlQueryParam(requestURL, "size", *r.size)
    }
    if r.blame!=nil {
        withUrlQueryParam(requestURL, "blame", *r.blame)
    }
    if r.type_!=nil {
        withUrlQueryParam(requestURL, "type", *r.type_)
    }
    return a.makeGetContent1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetContent1(ctx context.Context, path string, projectKey string, repositorySlug string, noContent string, at string, size string, blame string, type_ string) (GetContent1200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/browse/{path}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{path}", urlUtil.PathEscape(path))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "noContent", noContent)
    withUrlQueryParam(requestURL, "at", at)
    withUrlQueryParam(requestURL, "size", size)
    withUrlQueryParam(requestURL, "blame", blame)
    withUrlQueryParam(requestURL, "type", type_)
    return a.makeGetContent1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetContent1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (GetContent1200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result GetContent1200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[GetContent1200Response](&response)
        if err == nil {
            result = response.Body.(GetContent1200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetDefaultBranch1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
}

func (r *RepositoryAPIGetDefaultBranch1Request) Execute() (RestBranch, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetDefaultBranch1Execute(r)
}

func (a *RepositoryAPIRepository) GetDefaultBranch1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetDefaultBranch1Request {
    return RepositoryAPIGetDefaultBranch1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

// Deprecated
func (a *RepositoryAPIRepository) GetDefaultBranch1Execute(r *RepositoryAPIGetDefaultBranch1Request) (RestBranch, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/branches/default"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetDefaultBranch1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetDefaultBranch1(ctx context.Context, projectKey string, repositorySlug string) (RestBranch, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/branches/default"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetDefaultBranch1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetDefaultBranch1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestBranch, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result RestBranch
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestBranch](&response)
        if err == nil {
            result = response.Body.(RestBranch)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetLatestInvocation1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    webhookId string
    repositorySlug string
    event *string
    outcome *string
}

    // The string ID of a specific event to retrieve the last invocation for.
func (r *RepositoryAPIGetLatestInvocation1Request) Event(event string) *RepositoryAPIGetLatestInvocation1Request {
    r.event = &event
    return r
}

    // The outcome to filter for. Can be SUCCESS, FAILURE, ERROR. None specified means that the all will be considered
func (r *RepositoryAPIGetLatestInvocation1Request) Outcome(outcome string) *RepositoryAPIGetLatestInvocation1Request {
    r.outcome = &outcome
    return r
}

func (r *RepositoryAPIGetLatestInvocation1Request) Execute() (RestDetailedInvocation, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetLatestInvocation1Execute(r)
}

func (a *RepositoryAPIRepository) GetLatestInvocation1Request(ctx context.Context, projectKey string, webhookId string, repositorySlug string) RepositoryAPIGetLatestInvocation1Request {
    return RepositoryAPIGetLatestInvocation1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        webhookId: webhookId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetLatestInvocation1Execute(r *RepositoryAPIGetLatestInvocation1Request) (RestDetailedInvocation, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}/latest"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{webhookId}", urlUtil.PathEscape(r.webhookId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.event!=nil {
        withUrlQueryParam(requestURL, "event", *r.event)
    }
    if r.outcome!=nil {
        withUrlQueryParam(requestURL, "outcome", *r.outcome)
    }
    return a.makeGetLatestInvocation1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetLatestInvocation1(ctx context.Context, projectKey string, webhookId string, repositorySlug string, event string, outcome string) (RestDetailedInvocation, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}/latest"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{webhookId}", urlUtil.PathEscape(webhookId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "event", event)
    withUrlQueryParam(requestURL, "outcome", outcome)
    return a.makeGetLatestInvocation1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetLatestInvocation1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestDetailedInvocation, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result RestDetailedInvocation
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestDetailedInvocation](&response)
        if err == nil {
            result = response.Body.(RestDetailedInvocation)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetMergeBaseRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    commitId string
    repositorySlug string
    otherCommitId *string
}

    // The other commit id to calculate the merge-base on
func (r *RepositoryAPIGetMergeBaseRequest) OtherCommitId(otherCommitId string) *RepositoryAPIGetMergeBaseRequest {
    r.otherCommitId = &otherCommitId
    return r
}

func (r *RepositoryAPIGetMergeBaseRequest) Execute() (RestCommit, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetMergeBaseExecute(r)
}

func (a *RepositoryAPIRepository) GetMergeBaseRequest(ctx context.Context, projectKey string, commitId string, repositorySlug string) RepositoryAPIGetMergeBaseRequest {
    return RepositoryAPIGetMergeBaseRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        commitId: commitId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetMergeBaseExecute(r *RepositoryAPIGetMergeBaseRequest) (RestCommit, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/merge-base"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(r.commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.otherCommitId!=nil {
        withUrlQueryParam(requestURL, "otherCommitId", *r.otherCommitId)
    }
    return a.makeGetMergeBaseCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetMergeBase(ctx context.Context, projectKey string, commitId string, repositorySlug string, otherCommitId string) (RestCommit, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/merge-base"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "otherCommitId", otherCommitId)
    return a.makeGetMergeBaseCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetMergeBaseCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestCommit, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result RestCommit
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestCommit](&response)
        if err == nil {
            result = response.Body.(RestCommit)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetPullRequestSettings1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
}

func (r *RepositoryAPIGetPullRequestSettings1Request) Execute() (RestRepositoryPullRequestSettings, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetPullRequestSettings1Execute(r)
}

func (a *RepositoryAPIRepository) GetPullRequestSettings1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetPullRequestSettings1Request {
    return RepositoryAPIGetPullRequestSettings1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetPullRequestSettings1Execute(r *RepositoryAPIGetPullRequestSettings1Request) (RestRepositoryPullRequestSettings, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/pull-requests"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetPullRequestSettings1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetPullRequestSettings1(ctx context.Context, projectKey string, repositorySlug string) (RestRepositoryPullRequestSettings, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/pull-requests"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetPullRequestSettings1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetPullRequestSettings1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestRepositoryPullRequestSettings, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result RestRepositoryPullRequestSettings
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestRepositoryPullRequestSettings](&response)
        if err == nil {
            result = response.Body.(RestRepositoryPullRequestSettings)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetRefChangeActivityRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    ref *string
    start *float32
    limit *float32
}

    // (optional) exact match for a ref ID to filter ref change activity for
func (r *RepositoryAPIGetRefChangeActivityRequest) Ref(ref string) *RepositoryAPIGetRefChangeActivityRequest {
    r.ref = &ref
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIGetRefChangeActivityRequest) Start(start float32) *RepositoryAPIGetRefChangeActivityRequest {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIGetRefChangeActivityRequest) Limit(limit float32) *RepositoryAPIGetRefChangeActivityRequest {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIGetRefChangeActivityRequest) Execute() (GetRefChangeActivity200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetRefChangeActivityExecute(r)
}

func (a *RepositoryAPIRepository) GetRefChangeActivityRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetRefChangeActivityRequest {
    return RepositoryAPIGetRefChangeActivityRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetRefChangeActivityExecute(r *RepositoryAPIGetRefChangeActivityRequest) (GetRefChangeActivity200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/ref-change-activities"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.ref!=nil {
        withUrlQueryParam(requestURL, "ref", *r.ref)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeGetRefChangeActivityCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetRefChangeActivity(ctx context.Context, projectKey string, repositorySlug string, ref string, start float32, limit float32) (GetRefChangeActivity200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/ref-change-activities"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "ref", ref)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeGetRefChangeActivityCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetRefChangeActivityCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (GetRefChangeActivity200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result GetRefChangeActivity200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[GetRefChangeActivity200Response](&response)
        if err == nil {
            result = response.Body.(GetRefChangeActivity200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetRepositories1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    archived *string
    projectname *string
    projectkey *string
    visibility *string
    name *string
    permission *string
    state *string
    start *float32
    limit *float32
}

    // (optional) if specified, this will limit the resulting repository list to ones whose are &lt;tt&gt;ACTIVE&lt;/tt&gt;, &lt;tt&gt;ARCHIVED&lt;/tt&gt; or &lt;tt&gt;ALL&lt;/tt&gt; for both. The match performed is case-insensitive. This filter defaults to &lt;tt&gt;ACTIVE&lt;/tt&gt; when not set. &lt;em&gt;Available since 8.0&lt;/em&gt;
func (r *RepositoryAPIGetRepositories1Request) Archived(archived string) *RepositoryAPIGetRepositories1Request {
    r.archived = &archived
    return r
}

    // (optional) if specified, this will limit the resulting repository list to ones whose project&#39;s name matches this parameter&#39;s value. The match performed is case-insensitive and any leading and/or trailing whitespace characters on the &lt;code&gt;projectname&lt;/code&gt; parameter will be stripped.
func (r *RepositoryAPIGetRepositories1Request) Projectname(projectname string) *RepositoryAPIGetRepositories1Request {
    r.projectname = &projectname
    return r
}

    // (optional) if specified, this will limit the resulting repository list to ones whose project&#39;s key matches this parameter&#39;s value. The match performed is case-insensitive and any leading  and/or trailing whitespace characters on the &lt;code&gt;projectKey&lt;/code&gt; parameter will be stripped. &lt;em&gt;Available since 8.0&lt;/em&gt;
func (r *RepositoryAPIGetRepositories1Request) Projectkey(projectkey string) *RepositoryAPIGetRepositories1Request {
    r.projectkey = &projectkey
    return r
}

    // (optional) if specified, this will limit the resulting repository list based on the repositories visibility. Valid values are &lt;em&gt;public&lt;/em&gt; or &lt;em&gt;private&lt;/em&gt;.
func (r *RepositoryAPIGetRepositories1Request) Visibility(visibility string) *RepositoryAPIGetRepositories1Request {
    r.visibility = &visibility
    return r
}

    // (optional) if specified, this will limit the resulting repository list to ones whose name matches this parameter&#39;s value. The match performed is case-insensitive and any leading and/or trailing whitespace characters on the &lt;code&gt;name&lt;/code&gt; parameter will be stripped.
func (r *RepositoryAPIGetRepositories1Request) Name(name string) *RepositoryAPIGetRepositories1Request {
    r.name = &name
    return r
}

    // (optional) if specified, it must be a valid repository permission level name and will limit the resulting repository list to ones that the requesting user has the specified permission level to. If not specified, the default implicit &#39;read&#39; permission level will be assumed. The currently supported explicit permission values are &lt;tt&gt;REPO_READ&lt;/tt&gt;, &lt;tt&gt;REPO_WRITE&lt;/tt&gt; and &lt;tt&gt;REPO_ADMIN&lt;/tt&gt;.
func (r *RepositoryAPIGetRepositories1Request) Permission(permission string) *RepositoryAPIGetRepositories1Request {
    r.permission = &permission
    return r
}

    // (optional) if specified, it must be a valid repository state name and will limit the resulting repository list to ones that are in the specified state. The currently supported explicit state values are &lt;tt&gt;AVAILABLE&lt;/tt&gt;, &lt;tt&gt;INITIALISING&lt;/tt&gt; and &lt;tt&gt;INITIALISATION_FAILED&lt;/tt&gt;.&lt;br&gt; &lt;em&gt;Available since 5.13&lt;/em&gt;
func (r *RepositoryAPIGetRepositories1Request) State(state string) *RepositoryAPIGetRepositories1Request {
    r.state = &state
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIGetRepositories1Request) Start(start float32) *RepositoryAPIGetRepositories1Request {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIGetRepositories1Request) Limit(limit float32) *RepositoryAPIGetRepositories1Request {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIGetRepositories1Request) Execute() (GetRepositoriesRecentlyAccessed200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetRepositories1Execute(r)
}

func (a *RepositoryAPIRepository) GetRepositories1Request(ctx context.Context) RepositoryAPIGetRepositories1Request {
    return RepositoryAPIGetRepositories1Request{
        ApiService: a,
        ctx: ctx,
    }
}

func (a *RepositoryAPIRepository) GetRepositories1Execute(r *RepositoryAPIGetRepositories1Request) (GetRepositoriesRecentlyAccessed200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/repos"
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.archived!=nil {
        withUrlQueryParam(requestURL, "archived", *r.archived)
    }
    if r.projectname!=nil {
        withUrlQueryParam(requestURL, "projectname", *r.projectname)
    }
    if r.projectkey!=nil {
        withUrlQueryParam(requestURL, "projectkey", *r.projectkey)
    }
    if r.visibility!=nil {
        withUrlQueryParam(requestURL, "visibility", *r.visibility)
    }
    if r.name!=nil {
        withUrlQueryParam(requestURL, "name", *r.name)
    }
    if r.permission!=nil {
        withUrlQueryParam(requestURL, "permission", *r.permission)
    }
    if r.state!=nil {
        withUrlQueryParam(requestURL, "state", *r.state)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeGetRepositories1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetRepositories1(ctx context.Context, archived string, projectname string, projectkey string, visibility string, name string, permission string, state string, start float32, limit float32) (GetRepositoriesRecentlyAccessed200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/repos"
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "archived", archived)
    withUrlQueryParam(requestURL, "projectname", projectname)
    withUrlQueryParam(requestURL, "projectkey", projectkey)
    withUrlQueryParam(requestURL, "visibility", visibility)
    withUrlQueryParam(requestURL, "name", name)
    withUrlQueryParam(requestURL, "permission", permission)
    withUrlQueryParam(requestURL, "state", state)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeGetRepositories1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetRepositories1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (GetRepositoriesRecentlyAccessed200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result GetRepositoriesRecentlyAccessed200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[GetRepositoriesRecentlyAccessed200Response](&response)
        if err == nil {
            result = response.Body.(GetRepositoriesRecentlyAccessed200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetRepositoriesRecentlyAccessedRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    permission *string
    start *float32
    limit *float32
}

    // (optional) If specified, it must be a valid repository permission level name and will limit the resulting repository list to ones that the requesting user has the specified permission level to. If not specified, the default &lt;code&gt;REPO_READ&lt;/code&gt; permission level will be assumed.
func (r *RepositoryAPIGetRepositoriesRecentlyAccessedRequest) Permission(permission string) *RepositoryAPIGetRepositoriesRecentlyAccessedRequest {
    r.permission = &permission
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIGetRepositoriesRecentlyAccessedRequest) Start(start float32) *RepositoryAPIGetRepositoriesRecentlyAccessedRequest {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIGetRepositoriesRecentlyAccessedRequest) Limit(limit float32) *RepositoryAPIGetRepositoriesRecentlyAccessedRequest {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIGetRepositoriesRecentlyAccessedRequest) Execute() (GetRepositoriesRecentlyAccessed200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetRepositoriesRecentlyAccessedExecute(r)
}

func (a *RepositoryAPIRepository) GetRepositoriesRecentlyAccessedRequest(ctx context.Context) RepositoryAPIGetRepositoriesRecentlyAccessedRequest {
    return RepositoryAPIGetRepositoriesRecentlyAccessedRequest{
        ApiService: a,
        ctx: ctx,
    }
}

func (a *RepositoryAPIRepository) GetRepositoriesRecentlyAccessedExecute(r *RepositoryAPIGetRepositoriesRecentlyAccessedRequest) (GetRepositoriesRecentlyAccessed200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/profile/recent/repos"
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.permission!=nil {
        withUrlQueryParam(requestURL, "permission", *r.permission)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeGetRepositoriesRecentlyAccessedCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetRepositoriesRecentlyAccessed(ctx context.Context, permission string, start float32, limit float32) (GetRepositoriesRecentlyAccessed200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/profile/recent/repos"
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "permission", permission)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeGetRepositoriesRecentlyAccessedCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetRepositoriesRecentlyAccessedCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (GetRepositoriesRecentlyAccessed200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result GetRepositoriesRecentlyAccessed200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[GetRepositoriesRecentlyAccessed200Response](&response)
        if err == nil {
            result = response.Body.(GetRepositoriesRecentlyAccessed200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetRepositoryHook1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    hookKey string
    repositorySlug string
}

func (r *RepositoryAPIGetRepositoryHook1Request) Execute() (RestRepositoryHook, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetRepositoryHook1Execute(r)
}

func (a *RepositoryAPIRepository) GetRepositoryHook1Request(ctx context.Context, projectKey string, hookKey string, repositorySlug string) RepositoryAPIGetRepositoryHook1Request {
    return RepositoryAPIGetRepositoryHook1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        hookKey: hookKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetRepositoryHook1Execute(r *RepositoryAPIGetRepositoryHook1Request) (RestRepositoryHook, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{hookKey}", urlUtil.PathEscape(r.hookKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetRepositoryHook1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetRepositoryHook1(ctx context.Context, projectKey string, hookKey string, repositorySlug string) (RestRepositoryHook, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{hookKey}", urlUtil.PathEscape(hookKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetRepositoryHook1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetRepositoryHook1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestRepositoryHook, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result RestRepositoryHook
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestRepositoryHook](&response)
        if err == nil {
            result = response.Body.(RestRepositoryHook)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetRepositoryHooks1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    type_ *string
    start *float32
    limit *float32
}

    // The optional type to filter by.
func (r *RepositoryAPIGetRepositoryHooks1Request) Type_(type_ string) *RepositoryAPIGetRepositoryHooks1Request {
    r.type_ = &type_
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIGetRepositoryHooks1Request) Start(start float32) *RepositoryAPIGetRepositoryHooks1Request {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIGetRepositoryHooks1Request) Limit(limit float32) *RepositoryAPIGetRepositoryHooks1Request {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIGetRepositoryHooks1Request) Execute() (GetRepositoryHooks1200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetRepositoryHooks1Execute(r)
}

func (a *RepositoryAPIRepository) GetRepositoryHooks1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetRepositoryHooks1Request {
    return RepositoryAPIGetRepositoryHooks1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetRepositoryHooks1Execute(r *RepositoryAPIGetRepositoryHooks1Request) (GetRepositoryHooks1200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.type_!=nil {
        withUrlQueryParam(requestURL, "type", *r.type_)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeGetRepositoryHooks1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetRepositoryHooks1(ctx context.Context, projectKey string, repositorySlug string, type_ string, start float32, limit float32) (GetRepositoryHooks1200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "type", type_)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeGetRepositoryHooks1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetRepositoryHooks1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (GetRepositoryHooks1200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result GetRepositoryHooks1200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[GetRepositoryHooks1200Response](&response)
        if err == nil {
            result = response.Body.(GetRepositoryHooks1200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetRestriction1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    id string
    repositorySlug string
}

func (r *RepositoryAPIGetRestriction1Request) Execute() (RestRefRestriction, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetRestriction1Execute(r)
}

func (a *RepositoryAPIRepository) GetRestriction1Request(ctx context.Context, projectKey string, id string, repositorySlug string) RepositoryAPIGetRestriction1Request {
    return RepositoryAPIGetRestriction1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        id: id,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetRestriction1Execute(r *RepositoryAPIGetRestriction1Request) (RestRefRestriction, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/branch-permissions/latest/projects/{projectKey}/repos/{repositorySlug}/restrictions/{id}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{id}", urlUtil.PathEscape(r.id))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetRestriction1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetRestriction1(ctx context.Context, projectKey string, id string, repositorySlug string) (RestRefRestriction, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/branch-permissions/latest/projects/{projectKey}/repos/{repositorySlug}/restrictions/{id}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{id}", urlUtil.PathEscape(id))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetRestriction1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetRestriction1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestRefRestriction, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result RestRefRestriction
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestRefRestriction](&response)
        if err == nil {
            result = response.Body.(RestRefRestriction)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetRestrictions1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    matcherType *string
    matcherId *string
    type_ *string
    start *float32
    limit *float32
}

    // Matcher type to filter on
func (r *RepositoryAPIGetRestrictions1Request) MatcherType(matcherType string) *RepositoryAPIGetRestrictions1Request {
    r.matcherType = &matcherType
    return r
}

    // Matcher id to filter on. Requires the matcherType parameter to be specified also.
func (r *RepositoryAPIGetRestrictions1Request) MatcherId(matcherId string) *RepositoryAPIGetRestrictions1Request {
    r.matcherId = &matcherId
    return r
}

    // Types of restrictions to filter on.
func (r *RepositoryAPIGetRestrictions1Request) Type_(type_ string) *RepositoryAPIGetRestrictions1Request {
    r.type_ = &type_
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIGetRestrictions1Request) Start(start float32) *RepositoryAPIGetRestrictions1Request {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIGetRestrictions1Request) Limit(limit float32) *RepositoryAPIGetRestrictions1Request {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIGetRestrictions1Request) Execute() (GetRestrictions1200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetRestrictions1Execute(r)
}

func (a *RepositoryAPIRepository) GetRestrictions1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetRestrictions1Request {
    return RepositoryAPIGetRestrictions1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetRestrictions1Execute(r *RepositoryAPIGetRestrictions1Request) (GetRestrictions1200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/branch-permissions/latest/projects/{projectKey}/repos/{repositorySlug}/restrictions"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.matcherType!=nil {
        withUrlQueryParam(requestURL, "matcherType", *r.matcherType)
    }
    if r.matcherId!=nil {
        withUrlQueryParam(requestURL, "matcherId", *r.matcherId)
    }
    if r.type_!=nil {
        withUrlQueryParam(requestURL, "type", *r.type_)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeGetRestrictions1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetRestrictions1(ctx context.Context, projectKey string, repositorySlug string, matcherType string, matcherId string, type_ string, start float32, limit float32) (GetRestrictions1200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/branch-permissions/latest/projects/{projectKey}/repos/{repositorySlug}/restrictions"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "matcherType", matcherType)
    withUrlQueryParam(requestURL, "matcherId", matcherId)
    withUrlQueryParam(requestURL, "type", type_)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeGetRestrictions1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetRestrictions1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (GetRestrictions1200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result GetRestrictions1200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[GetRestrictions1200Response](&response)
        if err == nil {
            result = response.Body.(GetRestrictions1200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetSettings1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    hookKey string
    repositorySlug string
}

func (r *RepositoryAPIGetSettings1Request) Execute() (ExampleSettings, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetSettings1Execute(r)
}

func (a *RepositoryAPIRepository) GetSettings1Request(ctx context.Context, projectKey string, hookKey string, repositorySlug string) RepositoryAPIGetSettings1Request {
    return RepositoryAPIGetSettings1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        hookKey: hookKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetSettings1Execute(r *RepositoryAPIGetSettings1Request) (ExampleSettings, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/settings"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{hookKey}", urlUtil.PathEscape(r.hookKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetSettings1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetSettings1(ctx context.Context, projectKey string, hookKey string, repositorySlug string) (ExampleSettings, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/settings"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{hookKey}", urlUtil.PathEscape(hookKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetSettings1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetSettings1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (ExampleSettings, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result ExampleSettings
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[ExampleSettings](&response)
        if err == nil {
            result = response.Body.(ExampleSettings)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetStatistics1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    webhookId string
    repositorySlug string
    event *string
}

    // The string ID of a specific event to retrieve the last invocation for. May be empty, in which case all events are considered
func (r *RepositoryAPIGetStatistics1Request) Event(event string) *RepositoryAPIGetStatistics1Request {
    r.event = &event
    return r
}

func (r *RepositoryAPIGetStatistics1Request) Execute() (interface{}, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetStatistics1Execute(r)
}

func (a *RepositoryAPIRepository) GetStatistics1Request(ctx context.Context, projectKey string, webhookId string, repositorySlug string) RepositoryAPIGetStatistics1Request {
    return RepositoryAPIGetStatistics1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        webhookId: webhookId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetStatistics1Execute(r *RepositoryAPIGetStatistics1Request) (interface{}, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}/statistics"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{webhookId}", urlUtil.PathEscape(r.webhookId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.event!=nil {
        withUrlQueryParam(requestURL, "event", *r.event)
    }
    return a.makeGetStatistics1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetStatistics1(ctx context.Context, projectKey string, webhookId string, repositorySlug string, event string) (interface{}, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}/statistics"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{webhookId}", urlUtil.PathEscape(webhookId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "event", event)
    return a.makeGetStatistics1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetStatistics1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (interface{}, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result interface{}
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[interface{}](&response)
        if err == nil {
            result = response.Body.(interface{})
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetStatisticsSummary1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    webhookId string
    repositorySlug string
}

func (r *RepositoryAPIGetStatisticsSummary1Request) Execute() (interface{}, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetStatisticsSummary1Execute(r)
}

func (a *RepositoryAPIRepository) GetStatisticsSummary1Request(ctx context.Context, projectKey string, webhookId string, repositorySlug string) RepositoryAPIGetStatisticsSummary1Request {
    return RepositoryAPIGetStatisticsSummary1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        webhookId: webhookId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetStatisticsSummary1Execute(r *RepositoryAPIGetStatisticsSummary1Request) (interface{}, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}/statistics/summary"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{webhookId}", urlUtil.PathEscape(r.webhookId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetStatisticsSummary1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetStatisticsSummary1(ctx context.Context, projectKey string, webhookId string, repositorySlug string) (interface{}, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}/statistics/summary"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{webhookId}", urlUtil.PathEscape(webhookId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetStatisticsSummary1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetStatisticsSummary1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (interface{}, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result interface{}
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[interface{}](&response)
        if err == nil {
            result = response.Body.(interface{})
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetStatusRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    at *string
}

    // Retrieves the synchronization status for the specified ref within the repository, rather than for the entire repository
func (r *RepositoryAPIGetStatusRequest) At(at string) *RepositoryAPIGetStatusRequest {
    r.at = &at
    return r
}

func (r *RepositoryAPIGetStatusRequest) Execute() (RestRefSyncStatus, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetStatusExecute(r)
}

func (a *RepositoryAPIRepository) GetStatusRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetStatusRequest {
    return RepositoryAPIGetStatusRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetStatusExecute(r *RepositoryAPIGetStatusRequest) (RestRefSyncStatus, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/sync/latest/projects/{projectKey}/repos/{repositorySlug}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.at!=nil {
        withUrlQueryParam(requestURL, "at", *r.at)
    }
    return a.makeGetStatusCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetStatus(ctx context.Context, projectKey string, repositorySlug string, at string) (RestRefSyncStatus, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/sync/latest/projects/{projectKey}/repos/{repositorySlug}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "at", at)
    return a.makeGetStatusCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetStatusCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestRefSyncStatus, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result RestRefSyncStatus
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestRefSyncStatus](&response)
        if err == nil {
            result = response.Body.(RestRefSyncStatus)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetTagRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    name string
    repositorySlug string
}

func (r *RepositoryAPIGetTagRequest) Execute() (RestTag, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetTagExecute(r)
}

func (a *RepositoryAPIRepository) GetTagRequest(ctx context.Context, projectKey string, name string, repositorySlug string) RepositoryAPIGetTagRequest {
    return RepositoryAPIGetTagRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        name: name,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetTagExecute(r *RepositoryAPIGetTagRequest) (RestTag, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/tags/{name}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{name}", urlUtil.PathEscape(r.name))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetTagCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetTag(ctx context.Context, projectKey string, name string, repositorySlug string) (RestTag, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/tags/{name}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{name}", urlUtil.PathEscape(name))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeGetTagCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetTagCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestTag, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result RestTag
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestTag](&response)
        if err == nil {
            result = response.Body.(RestTag)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetTagsRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    orderBy *string
    filterText *string
    start *float32
    limit *float32
}

    // Ordering of refs either ALPHABETICAL (by name) or MODIFICATION (last updated)
func (r *RepositoryAPIGetTagsRequest) OrderBy(orderBy string) *RepositoryAPIGetTagsRequest {
    r.orderBy = &orderBy
    return r
}

    // The text to match on.
func (r *RepositoryAPIGetTagsRequest) FilterText(filterText string) *RepositoryAPIGetTagsRequest {
    r.filterText = &filterText
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIGetTagsRequest) Start(start float32) *RepositoryAPIGetTagsRequest {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIGetTagsRequest) Limit(limit float32) *RepositoryAPIGetTagsRequest {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIGetTagsRequest) Execute() (GetTags200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetTagsExecute(r)
}

func (a *RepositoryAPIRepository) GetTagsRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIGetTagsRequest {
    return RepositoryAPIGetTagsRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetTagsExecute(r *RepositoryAPIGetTagsRequest) (GetTags200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/tags"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.orderBy!=nil {
        withUrlQueryParam(requestURL, "orderBy", *r.orderBy)
    }
    if r.filterText!=nil {
        withUrlQueryParam(requestURL, "filterText", *r.filterText)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeGetTagsCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetTags(ctx context.Context, projectKey string, repositorySlug string, orderBy string, filterText string, start float32, limit float32) (GetTags200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/tags"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "orderBy", orderBy)
    withUrlQueryParam(requestURL, "filterText", filterText)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeGetTagsCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetTagsCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (GetTags200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result GetTags200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[GetTags200Response](&response)
        if err == nil {
            result = response.Body.(GetTags200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIGetWebhook1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    webhookId string
    repositorySlug string
    statistics *string
}

    // &lt;code&gt;true&lt;/code&gt; if statistics should be provided for the webhook
func (r *RepositoryAPIGetWebhook1Request) Statistics(statistics string) *RepositoryAPIGetWebhook1Request {
    r.statistics = &statistics
    return r
}

func (r *RepositoryAPIGetWebhook1Request) Execute() (RestWebhook, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.GetWebhook1Execute(r)
}

func (a *RepositoryAPIRepository) GetWebhook1Request(ctx context.Context, projectKey string, webhookId string, repositorySlug string) RepositoryAPIGetWebhook1Request {
    return RepositoryAPIGetWebhook1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        webhookId: webhookId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) GetWebhook1Execute(r *RepositoryAPIGetWebhook1Request) (RestWebhook, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{webhookId}", urlUtil.PathEscape(r.webhookId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.statistics!=nil {
        withUrlQueryParam(requestURL, "statistics", *r.statistics)
    }
    return a.makeGetWebhook1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) GetWebhook1(ctx context.Context, projectKey string, webhookId string, repositorySlug string, statistics string) (RestWebhook, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{webhookId}", urlUtil.PathEscape(webhookId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "statistics", statistics)
    return a.makeGetWebhook1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeGetWebhook1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestWebhook, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result RestWebhook
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestWebhook](&response)
        if err == nil {
            result = response.Body.(RestWebhook)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIReactRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    commentId string
    commitId string
    emoticon string
    repositorySlug string
}

func (r *RepositoryAPIReactRequest) Execute() (RestUserReaction, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.ReactExecute(r)
}

func (a *RepositoryAPIRepository) ReactRequest(ctx context.Context, projectKey string, commentId string, commitId string, emoticon string, repositorySlug string) RepositoryAPIReactRequest {
    return RepositoryAPIReactRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        commentId: commentId,
        commitId: commitId,
        emoticon: emoticon,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) ReactExecute(r *RepositoryAPIReactRequest) (RestUserReaction, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/comment-likes/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}/reactions/{emoticon}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commentId}", urlUtil.PathEscape(r.commentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(r.commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{emoticon}", urlUtil.PathEscape(r.emoticon))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeReactCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) React(ctx context.Context, projectKey string, commentId string, commitId string, emoticon string, repositorySlug string) (RestUserReaction, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/comment-likes/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}/reactions/{emoticon}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commentId}", urlUtil.PathEscape(commentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{emoticon}", urlUtil.PathEscape(emoticon))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeReactCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeReactCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestUserReaction, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPut
	requestUrl := requestURL.String()

    var result RestUserReaction
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}

    if response.Status < 400 {
        err = safeUnmarshal[RestUserReaction](&response)
        if err == nil {
            result = response.Body.(RestUserReaction)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIRemoveConfiguration1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    scriptId string
    repositorySlug string
}

func (r *RepositoryAPIRemoveConfiguration1Request) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.RemoveConfiguration1Execute(r)
}

func (a *RepositoryAPIRepository) RemoveConfiguration1Request(ctx context.Context, projectKey string, scriptId string, repositorySlug string) RepositoryAPIRemoveConfiguration1Request {
    return RepositoryAPIRemoveConfiguration1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        scriptId: scriptId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) RemoveConfiguration1Execute(r *RepositoryAPIRemoveConfiguration1Request) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/hook-scripts/{scriptId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{scriptId}", urlUtil.PathEscape(r.scriptId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeRemoveConfiguration1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) RemoveConfiguration1(ctx context.Context, projectKey string, scriptId string, repositorySlug string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/hook-scripts/{scriptId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{scriptId}", urlUtil.PathEscape(scriptId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeRemoveConfiguration1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeRemoveConfiguration1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodDelete
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIRemoveLabelRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    labelName string
    repositorySlug string
}

func (r *RepositoryAPIRemoveLabelRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.RemoveLabelExecute(r)
}

func (a *RepositoryAPIRepository) RemoveLabelRequest(ctx context.Context, projectKey string, labelName string, repositorySlug string) RepositoryAPIRemoveLabelRequest {
    return RepositoryAPIRemoveLabelRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        labelName: labelName,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) RemoveLabelExecute(r *RepositoryAPIRemoveLabelRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/labels/{labelName}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{labelName}", urlUtil.PathEscape(r.labelName))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeRemoveLabelCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) RemoveLabel(ctx context.Context, projectKey string, labelName string, repositorySlug string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/labels/{labelName}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{labelName}", urlUtil.PathEscape(labelName))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeRemoveLabelCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeRemoveLabelCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodDelete
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPISaveAttachmentMetadataRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    attachmentId string
    repositorySlug string
    body *string
}

    // The attachment metadata can be any valid JSON content
func (r *RepositoryAPISaveAttachmentMetadataRequest) Body(body string) *RepositoryAPISaveAttachmentMetadataRequest {
    r.body = &body
    return r
}

func (r *RepositoryAPISaveAttachmentMetadataRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.SaveAttachmentMetadataExecute(r)
}

func (a *RepositoryAPIRepository) SaveAttachmentMetadataRequest(ctx context.Context, projectKey string, attachmentId string, repositorySlug string) RepositoryAPISaveAttachmentMetadataRequest {
    return RepositoryAPISaveAttachmentMetadataRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        attachmentId: attachmentId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) SaveAttachmentMetadataExecute(r *RepositoryAPISaveAttachmentMetadataRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}/metadata"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{attachmentId}", urlUtil.PathEscape(r.attachmentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeSaveAttachmentMetadataCall(r.ctx, requestURL, r.body)
}

func (a *RepositoryAPIRepository) SaveAttachmentMetadata(ctx context.Context, projectKey string, attachmentId string, repositorySlug string, body string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}/metadata"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{attachmentId}", urlUtil.PathEscape(attachmentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeSaveAttachmentMetadataCall(ctx, requestURL, body)
}

func (a *RepositoryAPIRepository) makeSaveAttachmentMetadataCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodPut
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPISearchWebhooksRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    scopeType *string
    event *string
    statistics *bool
}

    // Scopes to filter by. This parameter can be specified once e.g. \&quot;scopeType&#x3D;repository\&quot;, or twice e.g. \&quot;scopeType&#x3D;repository&amp;scopeType&#x3D;project\&quot;, to filter by more than one scope level. 
func (r *RepositoryAPISearchWebhooksRequest) ScopeType(scopeType string) *RepositoryAPISearchWebhooksRequest {
    r.scopeType = &scopeType
    return r
}

    // List of &lt;code&gt;com.atlassian.webhooks.WebhookEvent&lt;/code&gt; ids to filter for
func (r *RepositoryAPISearchWebhooksRequest) Event(event string) *RepositoryAPISearchWebhooksRequest {
    r.event = &event
    return r
}

    // &lt;code&gt;true&lt;/code&gt; if statistics should be provided for all found webhooks
func (r *RepositoryAPISearchWebhooksRequest) Statistics(statistics bool) *RepositoryAPISearchWebhooksRequest {
    r.statistics = &statistics
    return r
}

func (r *RepositoryAPISearchWebhooksRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.SearchWebhooksExecute(r)
}

func (a *RepositoryAPIRepository) SearchWebhooksRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPISearchWebhooksRequest {
    return RepositoryAPISearchWebhooksRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) SearchWebhooksExecute(r *RepositoryAPISearchWebhooksRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/search"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.scopeType!=nil {
        withUrlQueryParam(requestURL, "scopeType", *r.scopeType)
    }
    if r.event!=nil {
        withUrlQueryParam(requestURL, "event", *r.event)
    }
    if r.statistics!=nil {
        withUrlQueryParam(requestURL, "statistics", parameterValueToString(*r.statistics))
    }
    return a.makeSearchWebhooksCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) SearchWebhooks(ctx context.Context, projectKey string, repositorySlug string, scopeType string, event string, statistics bool) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/search"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "scopeType", scopeType)
    withUrlQueryParam(requestURL, "event", event)
    withUrlQueryParam(requestURL, "statistics", parameterValueToString(statistics))
    return a.makeSearchWebhooksCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeSearchWebhooksCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPISet1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    restAutoMergeSettingsRequest *RestAutoMergeSettingsRequest
}

    // The settings to create or update
func (r *RepositoryAPISet1Request) RestAutoMergeSettingsRequest(restAutoMergeSettingsRequest RestAutoMergeSettingsRequest) *RepositoryAPISet1Request {
    r.restAutoMergeSettingsRequest = &restAutoMergeSettingsRequest
    return r
}

func (r *RepositoryAPISet1Request) Execute() (RestAutoMergeRestrictedSettings, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.Set1Execute(r)
}

func (a *RepositoryAPIRepository) Set1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPISet1Request {
    return RepositoryAPISet1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) Set1Execute(r *RepositoryAPISet1Request) (RestAutoMergeRestrictedSettings, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-merge"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeSet1Call(r.ctx, requestURL, r.restAutoMergeSettingsRequest)
}

func (a *RepositoryAPIRepository) Set1(ctx context.Context, projectKey string, repositorySlug string, restAutoMergeSettingsRequest RestAutoMergeSettingsRequest) (RestAutoMergeRestrictedSettings, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-merge"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeSet1Call(ctx, requestURL, restAutoMergeSettingsRequest)
}

func (a *RepositoryAPIRepository) makeSet1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestAutoMergeRestrictedSettings, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPut
	requestUrl := requestURL.String()

    var result RestAutoMergeRestrictedSettings
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 403 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestAutoMergeRestrictedSettings](&response)
        if err == nil {
            result = response.Body.(RestAutoMergeRestrictedSettings)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPISetAutoDeclineSettings1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    restAutoDeclineSettingsRequest *RestAutoDeclineSettingsRequest
}

    // The settings to create or update
func (r *RepositoryAPISetAutoDeclineSettings1Request) RestAutoDeclineSettingsRequest(restAutoDeclineSettingsRequest RestAutoDeclineSettingsRequest) *RepositoryAPISetAutoDeclineSettings1Request {
    r.restAutoDeclineSettingsRequest = &restAutoDeclineSettingsRequest
    return r
}

func (r *RepositoryAPISetAutoDeclineSettings1Request) Execute() (RestAutoDeclineSettings, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.SetAutoDeclineSettings1Execute(r)
}

func (a *RepositoryAPIRepository) SetAutoDeclineSettings1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPISetAutoDeclineSettings1Request {
    return RepositoryAPISetAutoDeclineSettings1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) SetAutoDeclineSettings1Execute(r *RepositoryAPISetAutoDeclineSettings1Request) (RestAutoDeclineSettings, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-decline"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeSetAutoDeclineSettings1Call(r.ctx, requestURL, r.restAutoDeclineSettingsRequest)
}

func (a *RepositoryAPIRepository) SetAutoDeclineSettings1(ctx context.Context, projectKey string, repositorySlug string, restAutoDeclineSettingsRequest RestAutoDeclineSettingsRequest) (RestAutoDeclineSettings, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-decline"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeSetAutoDeclineSettings1Call(ctx, requestURL, restAutoDeclineSettingsRequest)
}

func (a *RepositoryAPIRepository) makeSetAutoDeclineSettings1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestAutoDeclineSettings, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPut
	requestUrl := requestURL.String()

    var result RestAutoDeclineSettings
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestAutoDeclineSettings](&response)
        if err == nil {
            result = response.Body.(RestAutoDeclineSettings)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPISetConfiguration1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    scriptId string
    repositorySlug string
    restHookScriptTriggers *RestHookScriptTriggers
}

    // The hook triggers for which the hook script should be run
func (r *RepositoryAPISetConfiguration1Request) RestHookScriptTriggers(restHookScriptTriggers RestHookScriptTriggers) *RepositoryAPISetConfiguration1Request {
    r.restHookScriptTriggers = &restHookScriptTriggers
    return r
}

func (r *RepositoryAPISetConfiguration1Request) Execute() (RestHookScriptConfig, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.SetConfiguration1Execute(r)
}

func (a *RepositoryAPIRepository) SetConfiguration1Request(ctx context.Context, projectKey string, scriptId string, repositorySlug string) RepositoryAPISetConfiguration1Request {
    return RepositoryAPISetConfiguration1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        scriptId: scriptId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) SetConfiguration1Execute(r *RepositoryAPISetConfiguration1Request) (RestHookScriptConfig, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/hook-scripts/{scriptId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{scriptId}", urlUtil.PathEscape(r.scriptId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeSetConfiguration1Call(r.ctx, requestURL, r.restHookScriptTriggers)
}

func (a *RepositoryAPIRepository) SetConfiguration1(ctx context.Context, projectKey string, scriptId string, repositorySlug string, restHookScriptTriggers RestHookScriptTriggers) (RestHookScriptConfig, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/hook-scripts/{scriptId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{scriptId}", urlUtil.PathEscape(scriptId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeSetConfiguration1Call(ctx, requestURL, restHookScriptTriggers)
}

func (a *RepositoryAPIRepository) makeSetConfiguration1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestHookScriptConfig, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPut
	requestUrl := requestURL.String()

    var result RestHookScriptConfig
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestHookScriptConfig](&response)
        if err == nil {
            result = response.Body.(RestHookScriptConfig)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPISetDefaultBranch1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    restBranch *RestBranch
}

    // The branch to set as default
func (r *RepositoryAPISetDefaultBranch1Request) RestBranch(restBranch RestBranch) *RepositoryAPISetDefaultBranch1Request {
    r.restBranch = &restBranch
    return r
}

func (r *RepositoryAPISetDefaultBranch1Request) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.SetDefaultBranch1Execute(r)
}

func (a *RepositoryAPIRepository) SetDefaultBranch1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPISetDefaultBranch1Request {
    return RepositoryAPISetDefaultBranch1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

// Deprecated
func (a *RepositoryAPIRepository) SetDefaultBranch1Execute(r *RepositoryAPISetDefaultBranch1Request) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/branches/default"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeSetDefaultBranch1Call(r.ctx, requestURL, r.restBranch)
}

func (a *RepositoryAPIRepository) SetDefaultBranch1(ctx context.Context, projectKey string, repositorySlug string, restBranch RestBranch) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/branches/default"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeSetDefaultBranch1Call(ctx, requestURL, restBranch)
}

func (a *RepositoryAPIRepository) makeSetDefaultBranch1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodPut
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPISetEnabledRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    restRefSyncStatus *RestRefSyncStatus
}

func (r *RepositoryAPISetEnabledRequest) RestRefSyncStatus(restRefSyncStatus RestRefSyncStatus) *RepositoryAPISetEnabledRequest {
    r.restRefSyncStatus = &restRefSyncStatus
    return r
}

func (r *RepositoryAPISetEnabledRequest) Execute() (RestRefSyncStatus, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.SetEnabledExecute(r)
}

func (a *RepositoryAPIRepository) SetEnabledRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPISetEnabledRequest {
    return RepositoryAPISetEnabledRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) SetEnabledExecute(r *RepositoryAPISetEnabledRequest) (RestRefSyncStatus, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/sync/latest/projects/{projectKey}/repos/{repositorySlug}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeSetEnabledCall(r.ctx, requestURL, r.restRefSyncStatus)
}

func (a *RepositoryAPIRepository) SetEnabled(ctx context.Context, projectKey string, repositorySlug string, restRefSyncStatus RestRefSyncStatus) (RestRefSyncStatus, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/sync/latest/projects/{projectKey}/repos/{repositorySlug}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeSetEnabledCall(ctx, requestURL, restRefSyncStatus)
}

func (a *RepositoryAPIRepository) makeSetEnabledCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestRefSyncStatus, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPost
	requestUrl := requestURL.String()

    var result RestRefSyncStatus
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestRefSyncStatus](&response)
        if err == nil {
            result = response.Body.(RestRefSyncStatus)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPISetSettings1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    hookKey string
    repositorySlug string
    exampleSettings *ExampleSettings
}

    // The raw settings.
func (r *RepositoryAPISetSettings1Request) ExampleSettings(exampleSettings ExampleSettings) *RepositoryAPISetSettings1Request {
    r.exampleSettings = &exampleSettings
    return r
}

func (r *RepositoryAPISetSettings1Request) Execute() (ExampleSettings, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.SetSettings1Execute(r)
}

func (a *RepositoryAPIRepository) SetSettings1Request(ctx context.Context, projectKey string, hookKey string, repositorySlug string) RepositoryAPISetSettings1Request {
    return RepositoryAPISetSettings1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        hookKey: hookKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) SetSettings1Execute(r *RepositoryAPISetSettings1Request) (ExampleSettings, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/settings"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{hookKey}", urlUtil.PathEscape(r.hookKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeSetSettings1Call(r.ctx, requestURL, r.exampleSettings)
}

func (a *RepositoryAPIRepository) SetSettings1(ctx context.Context, projectKey string, hookKey string, repositorySlug string, exampleSettings ExampleSettings) (ExampleSettings, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/settings"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{hookKey}", urlUtil.PathEscape(hookKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeSetSettings1Call(ctx, requestURL, exampleSettings)
}

func (a *RepositoryAPIRepository) makeSetSettings1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (ExampleSettings, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPut
	requestUrl := requestURL.String()

    var result ExampleSettings
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[ExampleSettings](&response)
        if err == nil {
            result = response.Body.(ExampleSettings)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIStreamRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    at *string
}

    // The commit to use as the starting point when listing files and calculating modifications
func (r *RepositoryAPIStreamRequest) At(at string) *RepositoryAPIStreamRequest {
    r.at = &at
    return r
}

func (r *RepositoryAPIStreamRequest) Execute() (ExampleFiles, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.StreamExecute(r)
}

func (a *RepositoryAPIRepository) StreamRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIStreamRequest {
    return RepositoryAPIStreamRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) StreamExecute(r *RepositoryAPIStreamRequest) (ExampleFiles, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/last-modified"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.at!=nil {
        withUrlQueryParam(requestURL, "at", *r.at)
    }
    return a.makeStreamCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) Stream(ctx context.Context, projectKey string, repositorySlug string, at string) (ExampleFiles, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/last-modified"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "at", at)
    return a.makeStreamCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeStreamCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (ExampleFiles, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result ExampleFiles
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[ExampleFiles](&response)
        if err == nil {
            result = response.Body.(ExampleFiles)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIStream1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    path string
    projectKey string
    repositorySlug string
    at *string
}

    // The commit to use as the starting point when listing files and calculating modifications
func (r *RepositoryAPIStream1Request) At(at string) *RepositoryAPIStream1Request {
    r.at = &at
    return r
}

func (r *RepositoryAPIStream1Request) Execute() (ExampleFiles, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.Stream1Execute(r)
}

func (a *RepositoryAPIRepository) Stream1Request(ctx context.Context, path string, projectKey string, repositorySlug string) RepositoryAPIStream1Request {
    return RepositoryAPIStream1Request{
        ApiService: a,
        ctx: ctx,
        path: path,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) Stream1Execute(r *RepositoryAPIStream1Request) (ExampleFiles, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/last-modified/{path}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{path}", urlUtil.PathEscape(r.path))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.at!=nil {
        withUrlQueryParam(requestURL, "at", *r.at)
    }
    return a.makeStream1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) Stream1(ctx context.Context, path string, projectKey string, repositorySlug string, at string) (ExampleFiles, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/last-modified/{path}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{path}", urlUtil.PathEscape(path))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "at", at)
    return a.makeStream1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeStream1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (ExampleFiles, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result ExampleFiles
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[ExampleFiles](&response)
        if err == nil {
            result = response.Body.(ExampleFiles)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIStreamChangesRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    fromRepo *string
    from *string
    to *string
    start *float32
    limit *float32
}

    // an optional parameter specifying the source repository containing the source commit if that commit is not present in the current repository; the repository can be specified by either its ID &lt;em&gt;fromRepo&#x3D;42&lt;/em&gt; or by its project key plus its repo slug separated by a slash: &lt;em&gt;fromRepo&#x3D;projectKey/repoSlug&lt;/em&gt;
func (r *RepositoryAPIStreamChangesRequest) FromRepo(fromRepo string) *RepositoryAPIStreamChangesRequest {
    r.fromRepo = &fromRepo
    return r
}

    // the source commit (can be a partial/full commit ID or qualified/unqualified ref name)
func (r *RepositoryAPIStreamChangesRequest) From(from string) *RepositoryAPIStreamChangesRequest {
    r.from = &from
    return r
}

    // the target commit (can be a partial/full commit ID or qualified/unqualified ref name)
func (r *RepositoryAPIStreamChangesRequest) To(to string) *RepositoryAPIStreamChangesRequest {
    r.to = &to
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIStreamChangesRequest) Start(start float32) *RepositoryAPIStreamChangesRequest {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIStreamChangesRequest) Limit(limit float32) *RepositoryAPIStreamChangesRequest {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIStreamChangesRequest) Execute() (GetChanges1200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.StreamChangesExecute(r)
}

func (a *RepositoryAPIRepository) StreamChangesRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIStreamChangesRequest {
    return RepositoryAPIStreamChangesRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) StreamChangesExecute(r *RepositoryAPIStreamChangesRequest) (GetChanges1200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/compare/changes"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.fromRepo!=nil {
        withUrlQueryParam(requestURL, "fromRepo", *r.fromRepo)
    }
    if r.from!=nil {
        withUrlQueryParam(requestURL, "from", *r.from)
    }
    if r.to!=nil {
        withUrlQueryParam(requestURL, "to", *r.to)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeStreamChangesCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) StreamChanges(ctx context.Context, projectKey string, repositorySlug string, fromRepo string, from string, to string, start float32, limit float32) (GetChanges1200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/compare/changes"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "fromRepo", fromRepo)
    withUrlQueryParam(requestURL, "from", from)
    withUrlQueryParam(requestURL, "to", to)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeStreamChangesCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeStreamChangesCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (GetChanges1200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result GetChanges1200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[GetChanges1200Response](&response)
        if err == nil {
            result = response.Body.(GetChanges1200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIStreamCommitsRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    fromRepo *string
    from *string
    to *string
    start *float32
    limit *float32
}

    // an optional parameter specifying the source repository containing the source commit if that commit is not present in the current repository; the repository can be specified by either its ID &lt;em&gt;fromRepo&#x3D;42&lt;/em&gt; or by its project key plus its repo slug separated by a slash: &lt;em&gt;fromRepo&#x3D;projectKey/repoSlug&lt;/em&gt;
func (r *RepositoryAPIStreamCommitsRequest) FromRepo(fromRepo string) *RepositoryAPIStreamCommitsRequest {
    r.fromRepo = &fromRepo
    return r
}

    // the source commit (can be a partial/full commit ID or qualified/unqualified ref name)
func (r *RepositoryAPIStreamCommitsRequest) From(from string) *RepositoryAPIStreamCommitsRequest {
    r.from = &from
    return r
}

    // the target commit (can be a partial/full commit ID or qualified/unqualified ref name)
func (r *RepositoryAPIStreamCommitsRequest) To(to string) *RepositoryAPIStreamCommitsRequest {
    r.to = &to
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIStreamCommitsRequest) Start(start float32) *RepositoryAPIStreamCommitsRequest {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIStreamCommitsRequest) Limit(limit float32) *RepositoryAPIStreamCommitsRequest {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIStreamCommitsRequest) Execute() (GetCommits200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.StreamCommitsExecute(r)
}

func (a *RepositoryAPIRepository) StreamCommitsRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIStreamCommitsRequest {
    return RepositoryAPIStreamCommitsRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) StreamCommitsExecute(r *RepositoryAPIStreamCommitsRequest) (GetCommits200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/compare/commits"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.fromRepo!=nil {
        withUrlQueryParam(requestURL, "fromRepo", *r.fromRepo)
    }
    if r.from!=nil {
        withUrlQueryParam(requestURL, "from", *r.from)
    }
    if r.to!=nil {
        withUrlQueryParam(requestURL, "to", *r.to)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeStreamCommitsCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) StreamCommits(ctx context.Context, projectKey string, repositorySlug string, fromRepo string, from string, to string, start float32, limit float32) (GetCommits200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/compare/commits"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "fromRepo", fromRepo)
    withUrlQueryParam(requestURL, "from", from)
    withUrlQueryParam(requestURL, "to", to)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeStreamCommitsCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeStreamCommitsCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (GetCommits200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result GetCommits200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[GetCommits200Response](&response)
        if err == nil {
            result = response.Body.(GetCommits200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIStreamDiffRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    commitId string
    repositorySlug string
    path string
    projectKey string
    srcPath *string
    avatarSize *string
    filter *string
    avatarScheme *string
    contextLines *string
    autoSrcPath *string
    whitespace *string
    withComments *string
    since *string
}

    // The source path for the file, if it was copied, moved or renamed
func (r *RepositoryAPIStreamDiffRequest) SrcPath(srcPath string) *RepositoryAPIStreamDiffRequest {
    r.srcPath = &srcPath
    return r
}

    // If present the service adds avatar URLs for comment authors where the provided value specifies the desired avatar size in pixels. Not applicable if streaming raw diff
func (r *RepositoryAPIStreamDiffRequest) AvatarSize(avatarSize string) *RepositoryAPIStreamDiffRequest {
    r.avatarSize = &avatarSize
    return r
}

    // Text used to filter files and lines (optional). Not applicable if streaming raw diff
func (r *RepositoryAPIStreamDiffRequest) Filter(filter string) *RepositoryAPIStreamDiffRequest {
    r.filter = &filter
    return r
}

    // The security scheme for avatar URLs. If the scheme is not present then it is inherited from the request. It can be set to \&quot;https\&quot; to force the use of secure URLs. Not applicable if streaming raw diff
func (r *RepositoryAPIStreamDiffRequest) AvatarScheme(avatarScheme string) *RepositoryAPIStreamDiffRequest {
    r.avatarScheme = &avatarScheme
    return r
}

    // The number of context lines to include around added/removed lines in the diff.Not applicable if streaming raw diff
func (r *RepositoryAPIStreamDiffRequest) ContextLines(contextLines string) *RepositoryAPIStreamDiffRequest {
    r.contextLines = &contextLines
    return r
}

    // &lt;code&gt;true&lt;/code&gt; to automatically try to find the source path when it&#39;s not provided, &lt;code&gt;false&lt;/code&gt; otherwise. Requires the path to be provided.
func (r *RepositoryAPIStreamDiffRequest) AutoSrcPath(autoSrcPath string) *RepositoryAPIStreamDiffRequest {
    r.autoSrcPath = &autoSrcPath
    return r
}

    // Optional whitespace flag which can be set to ignore-all
func (r *RepositoryAPIStreamDiffRequest) Whitespace(whitespace string) *RepositoryAPIStreamDiffRequest {
    r.whitespace = &whitespace
    return r
}

    // &lt;code&gt;true&lt;/code&gt; to embed comments in the diff (the default); otherwise &lt;code&gt;false&lt;/code&gt; to stream the diff without comments. Not applicable if streaming raw diff
func (r *RepositoryAPIStreamDiffRequest) WithComments(withComments string) *RepositoryAPIStreamDiffRequest {
    r.withComments = &withComments
    return r
}

    // The base revision to diff from. If omitted the parent revision of the until revision is used
func (r *RepositoryAPIStreamDiffRequest) Since(since string) *RepositoryAPIStreamDiffRequest {
    r.since = &since
    return r
}

func (r *RepositoryAPIStreamDiffRequest) Execute() (RestDiff, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.StreamDiffExecute(r)
}

func (a *RepositoryAPIRepository) StreamDiffRequest(ctx context.Context, commitId string, repositorySlug string, path string, projectKey string) RepositoryAPIStreamDiffRequest {
    return RepositoryAPIStreamDiffRequest{
        ApiService: a,
        ctx: ctx,
        commitId: commitId,
        repositorySlug: repositorySlug,
        path: path,
        projectKey: projectKey,
    }
}

func (a *RepositoryAPIRepository) StreamDiffExecute(r *RepositoryAPIStreamDiffRequest) (RestDiff, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/diff/{path}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(r.commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{path}", urlUtil.PathEscape(r.path))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.srcPath!=nil {
        withUrlQueryParam(requestURL, "srcPath", *r.srcPath)
    }
    if r.avatarSize!=nil {
        withUrlQueryParam(requestURL, "avatarSize", *r.avatarSize)
    }
    if r.filter!=nil {
        withUrlQueryParam(requestURL, "filter", *r.filter)
    }
    if r.avatarScheme!=nil {
        withUrlQueryParam(requestURL, "avatarScheme", *r.avatarScheme)
    }
    if r.contextLines!=nil {
        withUrlQueryParam(requestURL, "contextLines", *r.contextLines)
    }
    if r.autoSrcPath!=nil {
        withUrlQueryParam(requestURL, "autoSrcPath", *r.autoSrcPath)
    }
    if r.whitespace!=nil {
        withUrlQueryParam(requestURL, "whitespace", *r.whitespace)
    }
    if r.withComments!=nil {
        withUrlQueryParam(requestURL, "withComments", *r.withComments)
    }
    if r.since!=nil {
        withUrlQueryParam(requestURL, "since", *r.since)
    }
    return a.makeStreamDiffCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) StreamDiff(ctx context.Context, commitId string, repositorySlug string, path string, projectKey string, srcPath string, avatarSize string, filter string, avatarScheme string, contextLines string, autoSrcPath string, whitespace string, withComments string, since string) (RestDiff, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/diff/{path}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{path}", urlUtil.PathEscape(path))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "srcPath", srcPath)
    withUrlQueryParam(requestURL, "avatarSize", avatarSize)
    withUrlQueryParam(requestURL, "filter", filter)
    withUrlQueryParam(requestURL, "avatarScheme", avatarScheme)
    withUrlQueryParam(requestURL, "contextLines", contextLines)
    withUrlQueryParam(requestURL, "autoSrcPath", autoSrcPath)
    withUrlQueryParam(requestURL, "whitespace", whitespace)
    withUrlQueryParam(requestURL, "withComments", withComments)
    withUrlQueryParam(requestURL, "since", since)
    return a.makeStreamDiffCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeStreamDiffCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestDiff, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result RestDiff
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestDiff](&response)
        if err == nil {
            result = response.Body.(RestDiff)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIStreamDiff1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    path string
    projectKey string
    repositorySlug string
    contextLines *string
    fromRepo *string
    srcPath *string
    from *string
    to *string
    whitespace *string
    start *float32
    limit *float32
}

    // an optional number of context lines to include around each added or removed lines in the diff
func (r *RepositoryAPIStreamDiff1Request) ContextLines(contextLines string) *RepositoryAPIStreamDiff1Request {
    r.contextLines = &contextLines
    return r
}

    // an optional parameter specifying the source repository containing the source commit if that commit is not present in the current repository; the repository can be specified by either its ID &lt;em&gt;fromRepo&#x3D;42&lt;/em&gt; or by its project key plus its repo slug separated by a slash: &lt;em&gt;fromRepo&#x3D;projectKey/repoSlug&lt;/em&gt;
func (r *RepositoryAPIStreamDiff1Request) FromRepo(fromRepo string) *RepositoryAPIStreamDiff1Request {
    r.fromRepo = &fromRepo
    return r
}

    // source path
func (r *RepositoryAPIStreamDiff1Request) SrcPath(srcPath string) *RepositoryAPIStreamDiff1Request {
    r.srcPath = &srcPath
    return r
}

    // the source commit (can be a partial/full commit ID or qualified/unqualified ref name)
func (r *RepositoryAPIStreamDiff1Request) From(from string) *RepositoryAPIStreamDiff1Request {
    r.from = &from
    return r
}

    // the target commit (can be a partial/full commit ID or qualified/unqualified ref name)
func (r *RepositoryAPIStreamDiff1Request) To(to string) *RepositoryAPIStreamDiff1Request {
    r.to = &to
    return r
}

    // an optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt;
func (r *RepositoryAPIStreamDiff1Request) Whitespace(whitespace string) *RepositoryAPIStreamDiff1Request {
    r.whitespace = &whitespace
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIStreamDiff1Request) Start(start float32) *RepositoryAPIStreamDiff1Request {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIStreamDiff1Request) Limit(limit float32) *RepositoryAPIStreamDiff1Request {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIStreamDiff1Request) Execute() (StreamDiff1200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.StreamDiff1Execute(r)
}

func (a *RepositoryAPIRepository) StreamDiff1Request(ctx context.Context, path string, projectKey string, repositorySlug string) RepositoryAPIStreamDiff1Request {
    return RepositoryAPIStreamDiff1Request{
        ApiService: a,
        ctx: ctx,
        path: path,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) StreamDiff1Execute(r *RepositoryAPIStreamDiff1Request) (StreamDiff1200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/compare/diff{path}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{path}", urlUtil.PathEscape(r.path))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.contextLines!=nil {
        withUrlQueryParam(requestURL, "contextLines", *r.contextLines)
    }
    if r.fromRepo!=nil {
        withUrlQueryParam(requestURL, "fromRepo", *r.fromRepo)
    }
    if r.srcPath!=nil {
        withUrlQueryParam(requestURL, "srcPath", *r.srcPath)
    }
    if r.from!=nil {
        withUrlQueryParam(requestURL, "from", *r.from)
    }
    if r.to!=nil {
        withUrlQueryParam(requestURL, "to", *r.to)
    }
    if r.whitespace!=nil {
        withUrlQueryParam(requestURL, "whitespace", *r.whitespace)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeStreamDiff1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) StreamDiff1(ctx context.Context, path string, projectKey string, repositorySlug string, contextLines string, fromRepo string, srcPath string, from string, to string, whitespace string, start float32, limit float32) (StreamDiff1200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/compare/diff{path}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{path}", urlUtil.PathEscape(path))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "contextLines", contextLines)
    withUrlQueryParam(requestURL, "fromRepo", fromRepo)
    withUrlQueryParam(requestURL, "srcPath", srcPath)
    withUrlQueryParam(requestURL, "from", from)
    withUrlQueryParam(requestURL, "to", to)
    withUrlQueryParam(requestURL, "whitespace", whitespace)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeStreamDiff1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeStreamDiff1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (StreamDiff1200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result StreamDiff1200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[StreamDiff1200Response](&response)
        if err == nil {
            result = response.Body.(StreamDiff1200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIStreamFilesRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    at *string
    start *float32
    limit *float32
}

    // The commit ID or ref (e.g. a branch or tag) to list the files at. If not specified the default branch will be used instead.
func (r *RepositoryAPIStreamFilesRequest) At(at string) *RepositoryAPIStreamFilesRequest {
    r.at = &at
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIStreamFilesRequest) Start(start float32) *RepositoryAPIStreamFilesRequest {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIStreamFilesRequest) Limit(limit float32) *RepositoryAPIStreamFilesRequest {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIStreamFilesRequest) Execute() (StreamFiles200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.StreamFilesExecute(r)
}

func (a *RepositoryAPIRepository) StreamFilesRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIStreamFilesRequest {
    return RepositoryAPIStreamFilesRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) StreamFilesExecute(r *RepositoryAPIStreamFilesRequest) (StreamFiles200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/files"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.at!=nil {
        withUrlQueryParam(requestURL, "at", *r.at)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeStreamFilesCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) StreamFiles(ctx context.Context, projectKey string, repositorySlug string, at string, start float32, limit float32) (StreamFiles200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/files"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "at", at)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeStreamFilesCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeStreamFilesCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (StreamFiles200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result StreamFiles200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[StreamFiles200Response](&response)
        if err == nil {
            result = response.Body.(StreamFiles200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIStreamFiles1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    path string
    projectKey string
    repositorySlug string
    at *string
    start *float32
    limit *float32
}

    // The commit ID or ref (e.g. a branch or tag) to list the files at. If not specified the default branch will be used instead.
func (r *RepositoryAPIStreamFiles1Request) At(at string) *RepositoryAPIStreamFiles1Request {
    r.at = &at
    return r
}

    // Start number for the page (inclusive). If not passed, first page is assumed.
func (r *RepositoryAPIStreamFiles1Request) Start(start float32) *RepositoryAPIStreamFiles1Request {
    r.start = &start
    return r
}

    // Number of items to return. If not passed, a page size of 25 is used.
func (r *RepositoryAPIStreamFiles1Request) Limit(limit float32) *RepositoryAPIStreamFiles1Request {
    r.limit = &limit
    return r
}

func (r *RepositoryAPIStreamFiles1Request) Execute() (StreamFiles200Response, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.StreamFiles1Execute(r)
}

func (a *RepositoryAPIRepository) StreamFiles1Request(ctx context.Context, path string, projectKey string, repositorySlug string) RepositoryAPIStreamFiles1Request {
    return RepositoryAPIStreamFiles1Request{
        ApiService: a,
        ctx: ctx,
        path: path,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) StreamFiles1Execute(r *RepositoryAPIStreamFiles1Request) (StreamFiles200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/files/{path}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{path}", urlUtil.PathEscape(r.path))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.at!=nil {
        withUrlQueryParam(requestURL, "at", *r.at)
    }
    if r.start!=nil {
        withUrlQueryParam(requestURL, "start", parameterValueToString(*r.start))
    }
    if r.limit!=nil {
        withUrlQueryParam(requestURL, "limit", parameterValueToString(*r.limit))
    }
    return a.makeStreamFiles1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) StreamFiles1(ctx context.Context, path string, projectKey string, repositorySlug string, at string, start float32, limit float32) (StreamFiles200Response, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/files/{path}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{path}", urlUtil.PathEscape(path))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "at", at)
    withUrlQueryParam(requestURL, "start", parameterValueToString(start))
    withUrlQueryParam(requestURL, "limit", parameterValueToString(limit))
    return a.makeStreamFiles1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeStreamFiles1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (StreamFiles200Response, aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    var result StreamFiles200Response
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[StreamFiles200Response](&response)
        if err == nil {
            result = response.Body.(StreamFiles200Response)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIStreamPatchRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    until *string
    allAncestors *string
    since *string
}

    // The target revision from which to generate the patch (required)
func (r *RepositoryAPIStreamPatchRequest) Until(until string) *RepositoryAPIStreamPatchRequest {
    r.until = &until
    return r
}

    // indicates whether or not to generate a patch which includes all the ancestors of the &#39;until&#39; revision. If true, the value provided by &#39;since&#39; is ignored.
func (r *RepositoryAPIStreamPatchRequest) AllAncestors(allAncestors string) *RepositoryAPIStreamPatchRequest {
    r.allAncestors = &allAncestors
    return r
}

    // The base revision from which to generate the patch. This is only applicable when &#39;allAncestors&#39; is false. If omitted the patch will represent one single commit, the &#39;until&#39;.
func (r *RepositoryAPIStreamPatchRequest) Since(since string) *RepositoryAPIStreamPatchRequest {
    r.since = &since
    return r
}

func (r *RepositoryAPIStreamPatchRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.StreamPatchExecute(r)
}

func (a *RepositoryAPIRepository) StreamPatchRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIStreamPatchRequest {
    return RepositoryAPIStreamPatchRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) StreamPatchExecute(r *RepositoryAPIStreamPatchRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/patch"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.until!=nil {
        withUrlQueryParam(requestURL, "until", *r.until)
    }
    if r.allAncestors!=nil {
        withUrlQueryParam(requestURL, "allAncestors", *r.allAncestors)
    }
    if r.since!=nil {
        withUrlQueryParam(requestURL, "since", *r.since)
    }
    return a.makeStreamPatchCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) StreamPatch(ctx context.Context, projectKey string, repositorySlug string, until string, allAncestors string, since string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/patch"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "until", until)
    withUrlQueryParam(requestURL, "allAncestors", allAncestors)
    withUrlQueryParam(requestURL, "since", since)
    return a.makeStreamPatchCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeStreamPatchCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIStreamRawRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    path string
    projectKey string
    repositorySlug string
    at *string
    markup *string
    htmlEscape *string
    includeHeadingId *string
    hardwrap *string
}

    // A specific commit or ref to retrieve the raw content at, or the default branch if not specified
func (r *RepositoryAPIStreamRawRequest) At(at string) *RepositoryAPIStreamRawRequest {
    r.at = &at
    return r
}

    // If present or \&quot;true\&quot;, triggers the raw content to be markup-rendered and returned as HTML; otherwise, if not specified, or any value other than \&quot;true\&quot;, the content is streamed without markup
func (r *RepositoryAPIStreamRawRequest) Markup(markup string) *RepositoryAPIStreamRawRequest {
    r.markup = &markup
    return r
}

    // (Optional) true if HTML should be escaped in the input markup, false otherwise. If not specified, the value of the markup.render.html.escape property, which is true by default, will be used
func (r *RepositoryAPIStreamRawRequest) HtmlEscape(htmlEscape string) *RepositoryAPIStreamRawRequest {
    r.htmlEscape = &htmlEscape
    return r
}

    // (Optional) true if headings should contain an ID based on the heading content. If not specified, the value of the markup.render.headerids property, which is false by default, will be used
func (r *RepositoryAPIStreamRawRequest) IncludeHeadingId(includeHeadingId string) *RepositoryAPIStreamRawRequest {
    r.includeHeadingId = &includeHeadingId
    return r
}

    // (Optional) Whether the markup implementation should convert newlines to breaks. If not specified, the value of the markup.render.hardwrap property, which is true by default, will be used
func (r *RepositoryAPIStreamRawRequest) Hardwrap(hardwrap string) *RepositoryAPIStreamRawRequest {
    r.hardwrap = &hardwrap
    return r
}

func (r *RepositoryAPIStreamRawRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.StreamRawExecute(r)
}

func (a *RepositoryAPIRepository) StreamRawRequest(ctx context.Context, path string, projectKey string, repositorySlug string) RepositoryAPIStreamRawRequest {
    return RepositoryAPIStreamRawRequest{
        ApiService: a,
        ctx: ctx,
        path: path,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) StreamRawExecute(r *RepositoryAPIStreamRawRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/raw/{path}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{path}", urlUtil.PathEscape(r.path))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.at!=nil {
        withUrlQueryParam(requestURL, "at", *r.at)
    }
    if r.markup!=nil {
        withUrlQueryParam(requestURL, "markup", *r.markup)
    }
    if r.htmlEscape!=nil {
        withUrlQueryParam(requestURL, "htmlEscape", *r.htmlEscape)
    }
    if r.includeHeadingId!=nil {
        withUrlQueryParam(requestURL, "includeHeadingId", *r.includeHeadingId)
    }
    if r.hardwrap!=nil {
        withUrlQueryParam(requestURL, "hardwrap", *r.hardwrap)
    }
    return a.makeStreamRawCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) StreamRaw(ctx context.Context, path string, projectKey string, repositorySlug string, at string, markup string, htmlEscape string, includeHeadingId string, hardwrap string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/raw/{path}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{path}", urlUtil.PathEscape(path))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "at", at)
    withUrlQueryParam(requestURL, "markup", markup)
    withUrlQueryParam(requestURL, "htmlEscape", htmlEscape)
    withUrlQueryParam(requestURL, "includeHeadingId", includeHeadingId)
    withUrlQueryParam(requestURL, "hardwrap", hardwrap)
    return a.makeStreamRawCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeStreamRawCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIStreamRawDiffRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    contextLines *string
    srcPath *string
    until *string
    whitespace *string
    since *string
}

    // The number of context lines to include around added/removed lines in the diff
func (r *RepositoryAPIStreamRawDiffRequest) ContextLines(contextLines string) *RepositoryAPIStreamRawDiffRequest {
    r.contextLines = &contextLines
    return r
}

    // The source path for the file, if it was copied, moved or renamed
func (r *RepositoryAPIStreamRawDiffRequest) SrcPath(srcPath string) *RepositoryAPIStreamRawDiffRequest {
    r.srcPath = &srcPath
    return r
}

    // The target revision to diff to (required)
func (r *RepositoryAPIStreamRawDiffRequest) Until(until string) *RepositoryAPIStreamRawDiffRequest {
    r.until = &until
    return r
}

    // Optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt;
func (r *RepositoryAPIStreamRawDiffRequest) Whitespace(whitespace string) *RepositoryAPIStreamRawDiffRequest {
    r.whitespace = &whitespace
    return r
}

    // The base revision to diff from. If omitted the parent revision of the until revision is used
func (r *RepositoryAPIStreamRawDiffRequest) Since(since string) *RepositoryAPIStreamRawDiffRequest {
    r.since = &since
    return r
}

func (r *RepositoryAPIStreamRawDiffRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.StreamRawDiffExecute(r)
}

func (a *RepositoryAPIRepository) StreamRawDiffRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIStreamRawDiffRequest {
    return RepositoryAPIStreamRawDiffRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) StreamRawDiffExecute(r *RepositoryAPIStreamRawDiffRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/diff"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.contextLines!=nil {
        withUrlQueryParam(requestURL, "contextLines", *r.contextLines)
    }
    if r.srcPath!=nil {
        withUrlQueryParam(requestURL, "srcPath", *r.srcPath)
    }
    if r.until!=nil {
        withUrlQueryParam(requestURL, "until", *r.until)
    }
    if r.whitespace!=nil {
        withUrlQueryParam(requestURL, "whitespace", *r.whitespace)
    }
    if r.since!=nil {
        withUrlQueryParam(requestURL, "since", *r.since)
    }
    return a.makeStreamRawDiffCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) StreamRawDiff(ctx context.Context, projectKey string, repositorySlug string, contextLines string, srcPath string, until string, whitespace string, since string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/diff"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "contextLines", contextLines)
    withUrlQueryParam(requestURL, "srcPath", srcPath)
    withUrlQueryParam(requestURL, "until", until)
    withUrlQueryParam(requestURL, "whitespace", whitespace)
    withUrlQueryParam(requestURL, "since", since)
    return a.makeStreamRawDiffCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeStreamRawDiffCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIStreamRawDiff1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    path string
    projectKey string
    repositorySlug string
    contextLines *string
    srcPath *string
    until *string
    whitespace *string
    since *string
}

    // The number of context lines to include around added/removed lines in the diff
func (r *RepositoryAPIStreamRawDiff1Request) ContextLines(contextLines string) *RepositoryAPIStreamRawDiff1Request {
    r.contextLines = &contextLines
    return r
}

    // The source path for the file, if it was copied, moved or renamed
func (r *RepositoryAPIStreamRawDiff1Request) SrcPath(srcPath string) *RepositoryAPIStreamRawDiff1Request {
    r.srcPath = &srcPath
    return r
}

    // The target revision to diff to (required)
func (r *RepositoryAPIStreamRawDiff1Request) Until(until string) *RepositoryAPIStreamRawDiff1Request {
    r.until = &until
    return r
}

    // Optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt;
func (r *RepositoryAPIStreamRawDiff1Request) Whitespace(whitespace string) *RepositoryAPIStreamRawDiff1Request {
    r.whitespace = &whitespace
    return r
}

    // The base revision to diff from. If omitted the parent revision of the until revision is used
func (r *RepositoryAPIStreamRawDiff1Request) Since(since string) *RepositoryAPIStreamRawDiff1Request {
    r.since = &since
    return r
}

func (r *RepositoryAPIStreamRawDiff1Request) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.StreamRawDiff1Execute(r)
}

func (a *RepositoryAPIRepository) StreamRawDiff1Request(ctx context.Context, path string, projectKey string, repositorySlug string) RepositoryAPIStreamRawDiff1Request {
    return RepositoryAPIStreamRawDiff1Request{
        ApiService: a,
        ctx: ctx,
        path: path,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) StreamRawDiff1Execute(r *RepositoryAPIStreamRawDiff1Request) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/diff/{path}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{path}", urlUtil.PathEscape(r.path))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.contextLines!=nil {
        withUrlQueryParam(requestURL, "contextLines", *r.contextLines)
    }
    if r.srcPath!=nil {
        withUrlQueryParam(requestURL, "srcPath", *r.srcPath)
    }
    if r.until!=nil {
        withUrlQueryParam(requestURL, "until", *r.until)
    }
    if r.whitespace!=nil {
        withUrlQueryParam(requestURL, "whitespace", *r.whitespace)
    }
    if r.since!=nil {
        withUrlQueryParam(requestURL, "since", *r.since)
    }
    return a.makeStreamRawDiff1Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) StreamRawDiff1(ctx context.Context, path string, projectKey string, repositorySlug string, contextLines string, srcPath string, until string, whitespace string, since string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/diff/{path}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{path}", urlUtil.PathEscape(path))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "contextLines", contextLines)
    withUrlQueryParam(requestURL, "srcPath", srcPath)
    withUrlQueryParam(requestURL, "until", until)
    withUrlQueryParam(requestURL, "whitespace", whitespace)
    withUrlQueryParam(requestURL, "since", since)
    return a.makeStreamRawDiff1Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeStreamRawDiff1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodGet
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPISynchronizeRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    restRefSyncRequest *RestRefSyncRequest
}

func (r *RepositoryAPISynchronizeRequest) RestRefSyncRequest(restRefSyncRequest RestRefSyncRequest) *RepositoryAPISynchronizeRequest {
    r.restRefSyncRequest = &restRefSyncRequest
    return r
}

func (r *RepositoryAPISynchronizeRequest) Execute() (RestRejectedRef, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.SynchronizeExecute(r)
}

func (a *RepositoryAPIRepository) SynchronizeRequest(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPISynchronizeRequest {
    return RepositoryAPISynchronizeRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) SynchronizeExecute(r *RepositoryAPISynchronizeRequest) (RestRejectedRef, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/sync/latest/projects/{projectKey}/repos/{repositorySlug}/synchronize"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeSynchronizeCall(r.ctx, requestURL, r.restRefSyncRequest)
}

func (a *RepositoryAPIRepository) Synchronize(ctx context.Context, projectKey string, repositorySlug string, restRefSyncRequest RestRefSyncRequest) (RestRejectedRef, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/sync/latest/projects/{projectKey}/repos/{repositorySlug}/synchronize"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeSynchronizeCall(ctx, requestURL, restRefSyncRequest)
}

func (a *RepositoryAPIRepository) makeSynchronizeCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestRejectedRef, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPost
	requestUrl := requestURL.String()

    var result RestRejectedRef
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 409 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 501 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestRejectedRef](&response)
        if err == nil {
            result = response.Body.(RestRejectedRef)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPITestWebhook1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    webhookId *int32
    sslVerificationRequired *string
    url *string
    restWebhookCredentials *RestWebhookCredentials
}

func (r *RepositoryAPITestWebhook1Request) WebhookId(webhookId int32) *RepositoryAPITestWebhook1Request {
    r.webhookId = &webhookId
    return r
}

    // Whether SSL verification is required for the specified webhook URL. Default value is  &lt;code&gt;true&lt;/code&gt;.
func (r *RepositoryAPITestWebhook1Request) SslVerificationRequired(sslVerificationRequired string) *RepositoryAPITestWebhook1Request {
    r.sslVerificationRequired = &sslVerificationRequired
    return r
}

    // The url in which to connect to
func (r *RepositoryAPITestWebhook1Request) Url(url string) *RepositoryAPITestWebhook1Request {
    r.url = &url
    return r
}

    // Basic authentication credentials, if required.
func (r *RepositoryAPITestWebhook1Request) RestWebhookCredentials(restWebhookCredentials RestWebhookCredentials) *RepositoryAPITestWebhook1Request {
    r.restWebhookCredentials = &restWebhookCredentials
    return r
}

func (r *RepositoryAPITestWebhook1Request) Execute() (interface{}, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.TestWebhook1Execute(r)
}

func (a *RepositoryAPIRepository) TestWebhook1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPITestWebhook1Request {
    return RepositoryAPITestWebhook1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) TestWebhook1Execute(r *RepositoryAPITestWebhook1Request) (interface{}, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/test"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    if r.webhookId!=nil {
        withUrlQueryParam(requestURL, "webhookId", parameterValueToString(*r.webhookId))
    }
    if r.sslVerificationRequired!=nil {
        withUrlQueryParam(requestURL, "sslVerificationRequired", *r.sslVerificationRequired)
    }
    if r.url!=nil {
        withUrlQueryParam(requestURL, "url", *r.url)
    }
    return a.makeTestWebhook1Call(r.ctx, requestURL, r.restWebhookCredentials)
}

func (a *RepositoryAPIRepository) TestWebhook1(ctx context.Context, projectKey string, repositorySlug string, restWebhookCredentials RestWebhookCredentials, webhookId int32, sslVerificationRequired string, url string) (interface{}, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/test"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    withUrlQueryParam(requestURL, "webhookId", parameterValueToString(webhookId))
    withUrlQueryParam(requestURL, "sslVerificationRequired", sslVerificationRequired)
    withUrlQueryParam(requestURL, "url", url)
    return a.makeTestWebhook1Call(ctx, requestURL, restWebhookCredentials)
}

func (a *RepositoryAPIRepository) makeTestWebhook1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (interface{}, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPost
	requestUrl := requestURL.String()

    var result interface{}
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[interface{}](&response)
        if err == nil {
            result = response.Body.(interface{})
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIUnReactRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    commentId string
    commitId string
    emoticon string
    repositorySlug string
}

func (r *RepositoryAPIUnReactRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.UnReactExecute(r)
}

func (a *RepositoryAPIRepository) UnReactRequest(ctx context.Context, projectKey string, commentId string, commitId string, emoticon string, repositorySlug string) RepositoryAPIUnReactRequest {
    return RepositoryAPIUnReactRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        commentId: commentId,
        commitId: commitId,
        emoticon: emoticon,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) UnReactExecute(r *RepositoryAPIUnReactRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/comment-likes/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}/reactions/{emoticon}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commentId}", urlUtil.PathEscape(r.commentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(r.commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{emoticon}", urlUtil.PathEscape(r.emoticon))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeUnReactCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) UnReact(ctx context.Context, projectKey string, commentId string, commitId string, emoticon string, repositorySlug string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/comment-likes/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}/reactions/{emoticon}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commentId}", urlUtil.PathEscape(commentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{emoticon}", urlUtil.PathEscape(emoticon))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeUnReactCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeUnReactCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodDelete
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIUnwatchRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    commitId string
    repositorySlug string
}

func (r *RepositoryAPIUnwatchRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.UnwatchExecute(r)
}

func (a *RepositoryAPIRepository) UnwatchRequest(ctx context.Context, projectKey string, commitId string, repositorySlug string) RepositoryAPIUnwatchRequest {
    return RepositoryAPIUnwatchRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        commitId: commitId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) UnwatchExecute(r *RepositoryAPIUnwatchRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/watch"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(r.commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeUnwatchCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) Unwatch(ctx context.Context, projectKey string, commitId string, repositorySlug string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/watch"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeUnwatchCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeUnwatchCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodDelete
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIUnwatch2Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
}

func (r *RepositoryAPIUnwatch2Request) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.Unwatch2Execute(r)
}

func (a *RepositoryAPIRepository) Unwatch2Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIUnwatch2Request {
    return RepositoryAPIUnwatch2Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) Unwatch2Execute(r *RepositoryAPIUnwatch2Request) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/watch"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeUnwatch2Call(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) Unwatch2(ctx context.Context, projectKey string, repositorySlug string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/watch"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeUnwatch2Call(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeUnwatch2Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodDelete
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIUpdateCommentRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    commentId string
    commitId string
    repositorySlug string
    restComment *RestComment
}

    // The comment to update
func (r *RepositoryAPIUpdateCommentRequest) RestComment(restComment RestComment) *RepositoryAPIUpdateCommentRequest {
    r.restComment = &restComment
    return r
}

func (r *RepositoryAPIUpdateCommentRequest) Execute() (RestComment, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.UpdateCommentExecute(r)
}

func (a *RepositoryAPIRepository) UpdateCommentRequest(ctx context.Context, projectKey string, commentId string, commitId string, repositorySlug string) RepositoryAPIUpdateCommentRequest {
    return RepositoryAPIUpdateCommentRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        commentId: commentId,
        commitId: commitId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) UpdateCommentExecute(r *RepositoryAPIUpdateCommentRequest) (RestComment, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commentId}", urlUtil.PathEscape(r.commentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(r.commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeUpdateCommentCall(r.ctx, requestURL, r.restComment)
}

func (a *RepositoryAPIRepository) UpdateComment(ctx context.Context, projectKey string, commentId string, commitId string, repositorySlug string, restComment RestComment) (RestComment, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commentId}", urlUtil.PathEscape(commentId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeUpdateCommentCall(ctx, requestURL, restComment)
}

func (a *RepositoryAPIRepository) makeUpdateCommentCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestComment, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPut
	requestUrl := requestURL.String()

    var result RestComment
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 409 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestComment](&response)
        if err == nil {
            result = response.Body.(RestComment)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIUpdatePullRequestSettings1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    restRepositoryPullRequestSettings *RestRepositoryPullRequestSettings
}

    // The updated settings.
func (r *RepositoryAPIUpdatePullRequestSettings1Request) RestRepositoryPullRequestSettings(restRepositoryPullRequestSettings RestRepositoryPullRequestSettings) *RepositoryAPIUpdatePullRequestSettings1Request {
    r.restRepositoryPullRequestSettings = &restRepositoryPullRequestSettings
    return r
}

func (r *RepositoryAPIUpdatePullRequestSettings1Request) Execute() (RestRepositoryPullRequestSettings, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.UpdatePullRequestSettings1Execute(r)
}

func (a *RepositoryAPIRepository) UpdatePullRequestSettings1Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIUpdatePullRequestSettings1Request {
    return RepositoryAPIUpdatePullRequestSettings1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) UpdatePullRequestSettings1Execute(r *RepositoryAPIUpdatePullRequestSettings1Request) (RestRepositoryPullRequestSettings, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/pull-requests"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeUpdatePullRequestSettings1Call(r.ctx, requestURL, r.restRepositoryPullRequestSettings)
}

func (a *RepositoryAPIRepository) UpdatePullRequestSettings1(ctx context.Context, projectKey string, repositorySlug string, restRepositoryPullRequestSettings RestRepositoryPullRequestSettings) (RestRepositoryPullRequestSettings, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/pull-requests"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeUpdatePullRequestSettings1Call(ctx, requestURL, restRepositoryPullRequestSettings)
}

func (a *RepositoryAPIRepository) makeUpdatePullRequestSettings1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestRepositoryPullRequestSettings, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPost
	requestUrl := requestURL.String()

    var result RestRepositoryPullRequestSettings
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 400 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestRepositoryPullRequestSettings](&response)
        if err == nil {
            result = response.Body.(RestRepositoryPullRequestSettings)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIUpdateWebhook1Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    webhookId string
    repositorySlug string
    restWebhook *RestWebhook
}

    // The representation of the updated values for the webhook
func (r *RepositoryAPIUpdateWebhook1Request) RestWebhook(restWebhook RestWebhook) *RepositoryAPIUpdateWebhook1Request {
    r.restWebhook = &restWebhook
    return r
}

func (r *RepositoryAPIUpdateWebhook1Request) Execute() (RestWebhook, aurestclientapi.ParsedResponse, error) {
    return r.ApiService.UpdateWebhook1Execute(r)
}

func (a *RepositoryAPIRepository) UpdateWebhook1Request(ctx context.Context, projectKey string, webhookId string, repositorySlug string) RepositoryAPIUpdateWebhook1Request {
    return RepositoryAPIUpdateWebhook1Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        webhookId: webhookId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) UpdateWebhook1Execute(r *RepositoryAPIUpdateWebhook1Request) (RestWebhook, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{webhookId}", urlUtil.PathEscape(r.webhookId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeUpdateWebhook1Call(r.ctx, requestURL, r.restWebhook)
}

func (a *RepositoryAPIRepository) UpdateWebhook1(ctx context.Context, projectKey string, webhookId string, repositorySlug string, restWebhook RestWebhook) (RestWebhook, aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{webhookId}", urlUtil.PathEscape(webhookId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeUpdateWebhook1Call(ctx, requestURL, restWebhook)
}

func (a *RepositoryAPIRepository) makeUpdateWebhook1Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (RestWebhook, aurestclientapi.ParsedResponse, error) {
	method := http.MethodPut
	requestUrl := requestURL.String()

    var result RestWebhook
    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return result,response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return result, response, err
    }

    if response.Status < 400 {
        err = safeUnmarshal[RestWebhook](&response)
        if err == nil {
            result = response.Body.(RestWebhook)
        }
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return result, response, err
}
 type RepositoryAPIWatchRequest struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    commitId string
    repositorySlug string
}

func (r *RepositoryAPIWatchRequest) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.WatchExecute(r)
}

func (a *RepositoryAPIRepository) WatchRequest(ctx context.Context, projectKey string, commitId string, repositorySlug string) RepositoryAPIWatchRequest {
    return RepositoryAPIWatchRequest{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        commitId: commitId,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) WatchExecute(r *RepositoryAPIWatchRequest) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/watch"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(r.commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeWatchCall(r.ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) Watch(ctx context.Context, projectKey string, commitId string, repositorySlug string) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/watch"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{commitId}", urlUtil.PathEscape(commitId))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeWatchCall(ctx, requestURL, nil)
}

func (a *RepositoryAPIRepository) makeWatchCall(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodPost
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}
 type RepositoryAPIWatch2Request struct {
    ctx context.Context
    ApiService *RepositoryAPIRepository
    projectKey string
    repositorySlug string
    restRepository *RestRepository
}

    // The repository to watch.
func (r *RepositoryAPIWatch2Request) RestRepository(restRepository RestRepository) *RepositoryAPIWatch2Request {
    r.restRepository = &restRepository
    return r
}

func (r *RepositoryAPIWatch2Request) Execute() (aurestclientapi.ParsedResponse, error) {
    return r.ApiService.Watch2Execute(r)
}

func (a *RepositoryAPIRepository) Watch2Request(ctx context.Context, projectKey string, repositorySlug string) RepositoryAPIWatch2Request {
    return RepositoryAPIWatch2Request{
        ApiService: a,
        ctx: ctx,
        projectKey: projectKey,
        repositorySlug: repositorySlug,
    }
}

func (a *RepositoryAPIRepository) Watch2Execute(r *RepositoryAPIWatch2Request) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/watch"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(r.projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(r.repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeWatch2Call(r.ctx, requestURL, r.restRepository)
}

func (a *RepositoryAPIRepository) Watch2(ctx context.Context, projectKey string, repositorySlug string, restRepository RestRepository) (aurestclientapi.ParsedResponse, error) {
    fullUrlValue := a.baseUrl() + "/api/latest/projects/{projectKey}/repos/{repositorySlug}/watch"
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{projectKey}", urlUtil.PathEscape(projectKey))
    fullUrlValue = strings.ReplaceAll(fullUrlValue, "{repositorySlug}", urlUtil.PathEscape(repositorySlug))
    requestURL, _ := urlUtil.Parse(fullUrlValue)
    return a.makeWatch2Call(ctx, requestURL, restRepository)
}

func (a *RepositoryAPIRepository) makeWatch2Call(ctx context.Context, requestURL *urlUtil.URL, requestBody any) (aurestclientapi.ParsedResponse, error) {
	method := http.MethodPost
	requestUrl := requestURL.String()

    emptyResponse := make([]byte, 0)
    responseBodyPointer := &emptyResponse
    response := aurestclientapi.ParsedResponse{
        Body: &responseBodyPointer,
    }
    err := a.httpClient().Perform(ctx, method, requestUrl, requestBody, &response)
	if err != nil {
		return response, err
	}
    if response.Status == 401 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }
    if response.Status == 404 {
		err = safeUnmarshal[DismissRetentionConfigReviewNotification401Response](&response)
        if err == nil {
            err = NewError(fmt.Sprintf("Got status %d", response.Status), response.Status)
        }
        return response, err
    }

    if response.Status < 400 {
    } else {
        err = NewError(fmt.Sprintf("Got unknown status %d", response.Status), response.Status)
    }
    return response, err
}

type RepositoryAPIRepository struct {
    ApiClient *ApiClient
}

func (c *RepositoryAPIRepository) baseUrl() string {
    return c.ApiClient.BaseUrl
}

func (c *RepositoryAPIRepository) httpClient() aurestclientapi.Client {
    return c.ApiClient.Client
}

func NewRepositoryAPI(client *ApiClient) RepositoryAPI {
    return &RepositoryAPIRepository{ApiClient: client}
}
