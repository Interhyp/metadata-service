/*
Bitbucket Data Center

This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).

API version: 8.19
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bitbucketclient

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	urlUtil "net/url"
	"strings"
	"time"

	aulogging "github.com/StephanHCB/go-autumn-logging"
	auloggingapi "github.com/StephanHCB/go-autumn-logging/api"
	auapmclient "github.com/StephanHCB/go-autumn-restclient-apm/implementation/client"
	aurestbreakerprometheus "github.com/StephanHCB/go-autumn-restclient-circuitbreaker-prometheus"
	aurestbreaker "github.com/StephanHCB/go-autumn-restclient-circuitbreaker/implementation/breaker"
	aurestclientprometheus "github.com/StephanHCB/go-autumn-restclient-prometheus"
	aurestclientapi "github.com/StephanHCB/go-autumn-restclient/api"
	aurestcaching "github.com/StephanHCB/go-autumn-restclient/implementation/caching"
	auresthttpclient "github.com/StephanHCB/go-autumn-restclient/implementation/httpclient"
	aurestrecorder "github.com/StephanHCB/go-autumn-restclient/implementation/recorder"
	aurestlogging "github.com/StephanHCB/go-autumn-restclient/implementation/requestlogging"
	aurestretry "github.com/StephanHCB/go-autumn-restclient/implementation/retry"
	"github.com/go-http-utils/headers"
)

const Authorization_ctx_value = "authorization"

type ApiClient struct {
	BaseUrl string
	Client  aurestclientapi.Client
}

func NewApiClient() (*ApiClient) {
    return &ApiClient{}
}

func NewApiClientConfigured(cfg *ClientConfig) (*ApiClient, error) {
    apiClient := NewApiClient()
    err := apiClient.SetupApiClient(cfg)
    return apiClient, err
}

// --- setup ---
func (c *ApiClient) SetupApiClient(cfg *ClientConfig) error {
	c.BaseUrl = cfg.BaseUrl

	//allow tests to pre-populate
	if c.Client != nil {
		return nil
	}

	client, err := setupHttpClient(cfg.RequestManipulator)
	if err != nil {
		return err
	}

	if cfg.LoggingConfigurer != nil {
		client = cfg.LoggingConfigurer(client)
	}

	if cfg.CircuitBreakerConfigurer != nil {
		client = cfg.CircuitBreakerConfigurer(client)
	}

	if cfg.ApmConfigurer != nil {
		client = cfg.ApmConfigurer(client)
	}

	if cfg.RetryConfigurer != nil {
		client = cfg.RetryConfigurer(client)
	}
	if cfg.RecorderConfigurer != nil {
		client = cfg.RecorderConfigurer(client)
	}
	if cfg.CachingConfigurer != nil {
		client = cfg.CachingConfigurer(client, cfg.CacheRetention, cfg.CacheSize)
	}

	c.Client = client

	return nil
}

type RequestManipulatorFunc func(ctx context.Context, r *http.Request)

func BasicAuthRequestManipulator(username string, password string) RequestManipulatorFunc {
	return func(ctx context.Context, r *http.Request) {
		r.SetBasicAuth(username, password)
	}
}

type ClientConfig struct {
	BaseUrl string

	CacheRetention time.Duration
	CacheSize      int

	RequestManipulator              RequestManipulatorFunc
	AuthorizationRequestManipulator RequestManipulatorFunc
	TracingRequestManipulator       RequestManipulatorFunc
	LoggingConfigurer               func(client aurestclientapi.Client) aurestclientapi.Client
	CircuitBreakerConfigurer        func(client aurestclientapi.Client) aurestclientapi.Client
	ApmConfigurer                   func(client aurestclientapi.Client) aurestclientapi.Client
	RetryConfigurer                 func(client aurestclientapi.Client) aurestclientapi.Client
	RecorderConfigurer              func(client aurestclientapi.Client) aurestclientapi.Client
	CachingConfigurer               func(client aurestclientapi.Client, cacheRetentionSeconds time.Duration, cacheSize int) aurestclientapi.Client
}

func DefaultApiClientConfig(baseUrl string) *ClientConfig {
	config := &ClientConfig{
		BaseUrl:                         baseUrl,
		RequestManipulator:              nil,
		AuthorizationRequestManipulator: authorizationHeaderSetter,
		TracingRequestManipulator:       nil,
		LoggingConfigurer:               setupLogging,
		CircuitBreakerConfigurer:        setupCircuitBreakerClient,
		ApmConfigurer:                   setupApm,
		RetryConfigurer:                 setupRetryClient,
		RecorderConfigurer:              setupRecorder,
		CachingConfigurer:               setupCachingClient,
		CacheRetention:                  60 * time.Second,
		CacheSize:                       1000,
	}
	config.RequestManipulator = requestHeaderManipulator(config)
	return config
}

func DefaultApiClientConfigNewWithOptions(baseUrl string) *ClientConfig {
	config := DefaultApiClientConfig(baseUrl)

	config.LoggingConfigurer = CreateSetupLoggingNewWithOptions(aurestlogging.Debug, aurestlogging.Info, aurestlogging.Info)
	config.RetryConfigurer = CreateRetryClientNewWithOptions(retryCondition(), betweenFailureAndRetry(), true)

	return config
}

func setupHttpClient(configuredHeaderManipulator func(ctx context.Context, r *http.Request)) (aurestclientapi.Client, error) {
	client, err := auresthttpclient.New(0, nil, configuredHeaderManipulator)
	if err != nil {
		return nil, err
	}
	aurestclientprometheus.InstrumentHttpClient(client)

	return client, nil
}

func requestHeaderManipulator(config *ClientConfig) func(ctx context.Context, r *http.Request) {
	return func(ctx context.Context, r *http.Request) {
		r.Header.Set(headers.Accept, aurestclientapi.ContentTypeApplicationJson)

		if config != nil && config.AuthorizationRequestManipulator != nil {
			config.AuthorizationRequestManipulator(ctx, r)
		}

		if config != nil && config.TracingRequestManipulator != nil {
			config.TracingRequestManipulator(ctx, r)
		}
	}
}

func authorizationHeaderSetter(ctx context.Context, r *http.Request) {
	ctxAuthorizationValue := ctx.Value(Authorization_ctx_value)
	if ctxAuthorizationValue != nil {
		ctxAuthrizationValueStr, ok := ctxAuthorizationValue.(string)
		if ok && ctxAuthrizationValueStr != "" {
			r.Header.Set(headers.Authorization, ctxAuthrizationValueStr)
		}
	}
}

func setupCircuitBreakerClient(client aurestclientapi.Client) aurestclientapi.Client {
	circuitBreakerWrapper := aurestbreaker.New(
		client,
		"Metadata",
		100,
		5*time.Minute,
		60*time.Second,
		// includes possible retries, once the context is cancelled further requests will fail directly
		15*time.Second,
	)
	aurestbreakerprometheus.InstrumentCircuitBreakerClient(circuitBreakerWrapper)
	return circuitBreakerWrapper
}

func CreateRetryClientNewWithOptions(retryConditionCallback aurestclientapi.RetryConditionCallback,
	beforeRetryCallback aurestclientapi.BeforeRetryCallback,
	silenceGivingUp bool) func(client aurestclientapi.Client) aurestclientapi.Client {
	return func(client aurestclientapi.Client) aurestclientapi.Client {
		retryWrapper := aurestretry.NewWithOptions(
			client,
			retryConditionCallback,
			aurestretry.RetryOptions{
				RepeatCount:      3,
				BeforeRetryOrNil: beforeRetryCallback,
				SilenceGivingUp:  silenceGivingUp,
			},
		)
		aurestclientprometheus.InstrumentRetryClient(retryWrapper)
		return retryWrapper
	}
}

func CreateSetupLoggingNewWithOptions(beforeRequestLogger func(ctx context.Context) auloggingapi.LeveledLoggingImplementation,
	successLogger func(ctx context.Context) auloggingapi.LeveledLoggingImplementation,
	failureLogger func(ctx context.Context) auloggingapi.LeveledLoggingImplementation) func(client aurestclientapi.Client) aurestclientapi.Client {

	return func(client aurestclientapi.Client) aurestclientapi.Client {
		return aurestlogging.NewWithOptions(client, aurestlogging.RequestLoggingOptions{
			BeforeRequest: beforeRequestLogger,
			Success:       successLogger,
			Failure:       failureLogger,
		})
	}
}

func setupRetryClient(client aurestclientapi.Client) aurestclientapi.Client {
	retryWrapper := aurestretry.New(
		client,
		3,
		retryCondition(),
		betweenFailureAndRetry(),
	)
	aurestclientprometheus.InstrumentRetryClient(retryWrapper)
	return retryWrapper
}

func retryCondition() aurestclientapi.RetryConditionCallback {
	return func(_ context.Context, response *aurestclientapi.ParsedResponse, err error) bool {
		return response.Status == http.StatusServiceUnavailable
	}
}

func betweenFailureAndRetry() aurestclientapi.BeforeRetryCallback {
	return func(ctx context.Context, originalResponse *aurestclientapi.ParsedResponse, originalError error) error {
		aulogging.Logger.Ctx(ctx).Warn().Print("got 503 from Metadata-endpoint - retrying request")
		return nil
	}
}

func setupCachingClient(client aurestclientapi.Client, cacheRetentionSeconds time.Duration, cacheSize int) aurestclientapi.Client {
	cacheWrapper := aurestcaching.New(
		client,
		func(ctx context.Context, method string, url string, requestBody interface{}) bool {
			return method == http.MethodGet
		},
		func(ctx context.Context, method string, url string, requestBody interface{}, response *aurestclientapi.ParsedResponse) bool {
			return response != nil && response.Status == http.StatusOK
		},
		nil,
		cacheRetentionSeconds,
		cacheSize,
	)
	aurestclientprometheus.InstrumentCacheClient(cacheWrapper)
	return cacheWrapper
}

func setupLogging(client aurestclientapi.Client) aurestclientapi.Client {
	return aurestlogging.New(client)
}

func setupApm(client aurestclientapi.Client) aurestclientapi.Client {
	return auapmclient.New(client)
}

func setupRecorder(client aurestclientapi.Client) aurestclientapi.Client {
	return aurestrecorder.New(client)
}

// --- request implementations ---

func safeUnmarshal[T any](response *aurestclientapi.ParsedResponse) error {
	var result T
	responseData, ok := response.Body.(**[]byte)
	if ok {
		if len(**responseData) > 0 {
			err := json.Unmarshal(**responseData, &result)
			if err != nil {
				return NewErrorWrap(err, response.Status)
			}
		}
		response.Body = result
	} else {
		return NewError(fmt.Sprintf("Something wrong"), response.Status)
	}
	return nil
}

func createMultipartRequestForFile(ctx context.Context, fileName string, fileContent string) (aurestclientapi.CustomRequestBody, error) {
	bufferBytes := &bytes.Buffer{}

	writer := multipart.NewWriter(bufferBytes)
	defer func(writer *multipart.Writer) {
		_ = writer.Close()
	}(writer)

	part, _ := writer.CreateFormFile("files", fmt.Sprintf("%s.txt", fileName))
	_, err := io.Copy(part, strings.NewReader(fileContent))
	if err != nil {
		return aurestclientapi.CustomRequestBody{}, err
	}

	return aurestclientapi.CustomRequestBody{
		BodyReader:  bufferBytes,
		BodyLength:  len(fileContent),
		ContentType: writer.FormDataContentType(),
	}, nil
}

// ---- helper methods

func withUrlQueryParam(requestUrl *urlUtil.URL, valueName string, value string) {
	if value != "" {
		queryParams := requestUrl.Query()
		queryParams.Add(valueName, value)
		requestUrl.RawQuery = queryParams.Encode()
	}
}

func parameterValueToString(obj interface{}) string {
	return fmt.Sprint(obj)
}

// A wrapper for strict JSON decoding
func newStrictDecoder(data []byte) *json.Decoder {
    dec := json.NewDecoder(bytes.NewBuffer(data))
    dec.DisallowUnknownFields()
    return dec
}